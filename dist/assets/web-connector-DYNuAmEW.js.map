{"version":3,"mappings":"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","names":["store","inMemoryStorage","key","value","getUserStatus","authToken","client","ecosystem","response","getClientFetch","getThirdwebBaseUrl","result","DOMAIN_URL_2023","BASE_URL_2023","ROUTE_2023_10_20_API_BASE_PATH","ROUTE_AUTH_JWT_CALLBACK","ROUTE_AUTH_ENDPOINT_CALLBACK","createErrorMessage","message","error","stringify","authEndpoint","args","res","verifiedToken","e","backendAuthenticate","clientFetch","path","getLoginUrl","guestAuthenticate","sessionId","randomBytesHex","getLoginCallbackUrl","customJwt","linkAccount","tokenToLink","storage","IN_APP_URL","currentAccountToken","headers","linkedDetailsResp","body","linkedAccounts","unlinkAccount","profileToUnlink","allowAccountDeletion","getLinkedProfilesInternal","linkedAccountsResp","getVerificationPath","getChallengePath","type","username","registerPasskey","options","fetchWithId","generatedName","generateUsername","challengeData","challenge","registration","customHeaders","verifData","loginWithPasskey","credentialId","r","authentication","NON_ETHEREUM_WALLETS","siweAuthenticate","wallet","chain","siweChain","getCachedChain","account","payload","signature","signLoginPayload","signAuthorization","signMessage","isRaw","originalMessage","chainId","signTransaction","signTypedData","EnclaveWallet","address","authResult","token","userStatus","authDetails","_signTransaction","tx","rpcRequest","getRpcClient","transaction","toHex","hexlify","__vitePreload","eth_getTransactionCount","getAddress","signEnclaveTransaction","signedTx","transactionHash","eth_sendRawTransaction","trackTransaction","authorization","signEnclaveAuthorization","messagePayload","bytesToHex","signEnclaveMessage","_typedData","parsedTypedData","parseTypedData","signEnclaveTypedData","inAppWalletSendCalls","firstCall","id","inAppWalletGetCallsStatus","isHex","iframeBaseStyle","isIframeLoaded","IframeCommunicator","link","baseUrl","iframeId","container","onIframeInitialize","localStorage","clientId","iframe","hrefLink","mergedIframeStyles","onIframeLoaded","event","channel","promise","rej","data","procedureName","params","showIframe","sleep","InAppWalletIframeCommunicator","IN_APP_WALLET_IFRAME_ID","createInAppWalletIframeLink","IN_APP_WALLET_PATH","ClientScopedStorage","webLocalStorage","queryParams","inAppWalletUrl","queryKey","generateWallet","AbstractLogin","querier","preLogin","postLogin","email","phoneNumber","BaseLogin","encryptionKey","jwt","otp","recoveryCode","Auth","onAuthSuccess","storedToken","walletDetails","user","isRemoveAuthCookie","isRemoveUserId","sendOtp","url","verifyOtp","IFrameWallet","partnerId","RPC_URL","getThirdwebDomains","signedTransaction","messageDecoded","hexToString","signedMessage","domain","domainData","signedTypedData","InAppWebConnector","passkeyDomain","getDefaultStorage","deviceShareStored","storedAuthToken","localAuthToken","strategy","mode","redirectUrl","loginWithOauthRedirect","loginWithOauth","assertUnreachable","PasskeyWebClient","n","passkeyName","storeLastUsedPasskey","passkeyClient","profile","x"],"ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24],"sources":["../../node_modules/thirdweb/dist/esm/utils/storage/inMemoryStorage.js","../../node_modules/thirdweb/dist/esm/wallets/in-app/core/actions/get-enclave-user-status.js","../../node_modules/thirdweb/dist/esm/wallets/in-app/native/helpers/constants.js","../../node_modules/thirdweb/dist/esm/wallets/in-app/native/helpers/errors.js","../../node_modules/thirdweb/dist/esm/wallets/in-app/core/authentication/authEndpoint.js","../../node_modules/thirdweb/dist/esm/wallets/in-app/core/authentication/backend.js","../../node_modules/thirdweb/dist/esm/wallets/in-app/core/authentication/guest.js","../../node_modules/thirdweb/dist/esm/wallets/in-app/core/authentication/jwt.js","../../node_modules/thirdweb/dist/esm/wallets/in-app/core/authentication/linkAccount.js","../../node_modules/thirdweb/dist/esm/wallets/in-app/core/authentication/passkeys.js","../../node_modules/thirdweb/dist/esm/wallets/in-app/core/authentication/siwe.js","../../node_modules/thirdweb/dist/esm/wallets/in-app/core/actions/sign-authorization.enclave.js","../../node_modules/thirdweb/dist/esm/wallets/in-app/core/actions/sign-message.enclave.js","../../node_modules/thirdweb/dist/esm/wallets/in-app/core/actions/sign-transaction.enclave.js","../../node_modules/thirdweb/dist/esm/wallets/in-app/core/actions/sign-typed-data.enclave.js","../../node_modules/thirdweb/dist/esm/wallets/in-app/core/wallet/enclave-wallet.js","../../node_modules/thirdweb/dist/esm/wallets/in-app/web/utils/iFrameCommunication/IframeCommunicator.js","../../node_modules/thirdweb/dist/esm/wallets/in-app/web/utils/iFrameCommunication/InAppWalletIframeCommunicator.js","../../node_modules/thirdweb/dist/esm/wallets/in-app/core/actions/generate-wallet.enclave.js","../../node_modules/thirdweb/dist/esm/wallets/in-app/web/lib/auth/abstract-login.js","../../node_modules/thirdweb/dist/esm/wallets/in-app/web/lib/auth/base-login.js","../../node_modules/thirdweb/dist/esm/wallets/in-app/web/lib/auth/iframe-auth.js","../../node_modules/thirdweb/dist/esm/wallets/in-app/web/lib/auth/otp.js","../../node_modules/thirdweb/dist/esm/wallets/in-app/web/lib/iframe-wallet.js","../../node_modules/thirdweb/dist/esm/wallets/in-app/web/lib/web-connector.js"],"sourcesContent":["const store = new Map();\nexport const inMemoryStorage = {\n    getItem: async (key) => {\n        return store.get(key) ?? null;\n    },\n    removeItem: async (key) => {\n        store.delete(key);\n    },\n    setItem: async (key, value) => {\n        store.set(key, value);\n    },\n};\n//# sourceMappingURL=inMemoryStorage.js.map","import { getThirdwebBaseUrl } from \"../../../../utils/domains.js\";\nimport { getClientFetch } from \"../../../../utils/fetch.js\";\n/**\n * Gets the user's status from the backend.\n *\n * @internal\n */\nexport async function getUserStatus({ authToken, client, ecosystem, }) {\n    const clientFetch = getClientFetch(client, ecosystem);\n    const response = await clientFetch(`${getThirdwebBaseUrl(\"inAppWallet\")}/api/2024-05-05/accounts`, {\n        headers: {\n            Authorization: `Bearer embedded-wallet-token:${authToken}`,\n            \"Content-Type\": \"application/json\",\n        },\n        method: \"GET\",\n    });\n    if (!response.ok) {\n        const result = await response.text().catch(() => {\n            return \"Unknown error\";\n        });\n        throw new Error(`Failed to get user info: ${result}`);\n    }\n    return (await response.json());\n}\n//# sourceMappingURL=get-enclave-user-status.js.map","import { getThirdwebBaseUrl } from \"../../../../utils/domains.js\";\nconst AUTH_SHARE_ID = 3;\nexport const AUTH_SHARE_INDEX = AUTH_SHARE_ID - 1;\nconst DEVICE_SHARE_ID = 1;\nexport const DEVICE_SHARE_INDEX = DEVICE_SHARE_ID - 1;\nexport const DEVICE_SHARE_MISSING_MESSAGE = \"Missing device share.\";\nexport const INVALID_DEVICE_SHARE_MESSAGE = \"Invalid private key reconstructed from shares\";\nconst RECOVERY_SHARE_ID = 2;\nexport const RECOVERY_SHARE_INDEX = RECOVERY_SHARE_ID - 1;\nexport const AWS_REGION = \"us-west-2\";\nexport const THIRDWEB_SESSION_NONCE_HEADER = \"x-session-nonce\";\nconst COGNITO_USER_POOL_ID = \"us-west-2_UFwLcZIpq\";\nexport const COGNITO_IDENTITY_POOL_ID = \"us-west-2:2ad7ab1e-f48b-48a6-adfa-ac1090689c26\";\nexport const GENERATE_RECOVERY_PASSWORD_LAMBDA_FUNCTION_V1 = \"arn:aws:lambda:us-west-2:324457261097:function:recovery-share-password-GenerateRecoverySharePassw-bbE5ZbVAToil\";\nexport const GENERATE_RECOVERY_PASSWORD_LAMBDA_FUNCTION_V2 = \"arn:aws:lambda:us-west-2:324457261097:function:lambda-thirdweb-auth-enc-key-prod-ThirdwebAuthEncKeyFunction\";\nexport const ENCLAVE_KMS_KEY_ARN = \"arn:aws:kms:us-west-2:324457261097:key/ccfb9ecd-f45d-4f37-864a-25fe72dcb49e\";\n// TODO allow overriding domain\nconst DOMAIN_URL_2023 = getThirdwebBaseUrl(\"inAppWallet\");\nconst BASE_URL_2023 = `${DOMAIN_URL_2023}/`;\nconst ROUTE_2023_10_20_API_BASE_PATH = `${BASE_URL_2023}api/2023-10-20`;\nconst ROUTE_2024_05_05_API_BASE_PATH = `${BASE_URL_2023}api/2024-05-05`;\nexport const ROUTE_EMBEDDED_WALLET_DETAILS = `${ROUTE_2023_10_20_API_BASE_PATH}/embedded-wallet/embedded-wallet-user-details`;\nexport const ROUTE_COGNITO_IDENTITY_POOL_URL = `cognito-idp.${AWS_REGION}.amazonaws.com/${COGNITO_USER_POOL_ID}`;\nexport const ROUTE_STORE_USER_SHARES = `${ROUTE_2023_10_20_API_BASE_PATH}/embedded-wallet/embedded-wallet-shares`;\nexport const ROUTE_GET_USER_SHARES = `${ROUTE_2023_10_20_API_BASE_PATH}/embedded-wallet/embedded-wallet-shares`;\nexport const ROUTE_VERIFY_THIRDWEB_CLIENT_ID = `${ROUTE_2023_10_20_API_BASE_PATH}/embedded-wallet/verify-thirdweb-client-id`;\nexport const ROUTE_AUTH_JWT_CALLBACK = `${ROUTE_2023_10_20_API_BASE_PATH}/embedded-wallet/validate-custom-jwt`;\nexport const ROUTE_AUTH_ENDPOINT_CALLBACK = `${ROUTE_2023_10_20_API_BASE_PATH}/embedded-wallet/validate-custom-auth-endpoint`;\nexport const ROUTE_AUTH_COGNITO_ID_TOKEN_V1 = `${ROUTE_2023_10_20_API_BASE_PATH}/embedded-wallet/cognito-id-token`;\nexport const ROUTE_AUTH_COGNITO_ID_TOKEN_V2 = `${ROUTE_2024_05_05_API_BASE_PATH}/login/web-token-exchange`;\n//# sourceMappingURL=constants.js.map","import { stringify } from \"../../../../utils/json.js\";\nexport const ErrorMessages = {\n    invalidOtp: \"Your OTP code is invalid or expired. Please request a new code or try again.\",\n    missingRecoveryCode: \"Missing encryption key for user\",\n};\nexport const createErrorMessage = (message, error) => {\n    if (error instanceof Error) {\n        return `${message}: ${error.message}`;\n    }\n    return `${message}: ${stringify(error)}`;\n};\n//# sourceMappingURL=errors.js.map","import { getClientFetch } from \"../../../../utils/fetch.js\";\nimport { stringify } from \"../../../../utils/json.js\";\nimport { ROUTE_AUTH_ENDPOINT_CALLBACK } from \"../../native/helpers/constants.js\";\nimport { createErrorMessage } from \"../../native/helpers/errors.js\";\nexport async function authEndpoint(args) {\n    const clientFetch = getClientFetch(args.client, args.ecosystem);\n    const res = await clientFetch(ROUTE_AUTH_ENDPOINT_CALLBACK, {\n        body: stringify({\n            developerClientId: args.client.clientId,\n            payload: args.payload,\n        }),\n        headers: {\n            \"Content-Type\": \"application/json\",\n        },\n        method: \"POST\",\n    });\n    if (!res.ok) {\n        const error = await res.json();\n        throw new Error(`Custom auth endpoint authentication error: ${error.message}`);\n    }\n    try {\n        const { verifiedToken } = await res.json();\n        return { storedToken: verifiedToken };\n    }\n    catch (e) {\n        throw new Error(createErrorMessage(\"Malformed response from post auth_endpoint authentication\", e));\n    }\n}\n//# sourceMappingURL=authEndpoint.js.map","import { getClientFetch } from \"../../../../utils/fetch.js\";\nimport { stringify } from \"../../../../utils/json.js\";\nimport { getLoginUrl } from \"./getLoginPath.js\";\n/**\n * Authenticates via the wallet secret\n * @internal\n */\nexport async function backendAuthenticate(args) {\n    const clientFetch = getClientFetch(args.client, args.ecosystem);\n    const path = getLoginUrl({\n        authOption: \"backend\",\n        client: args.client,\n        ecosystem: args.ecosystem,\n    });\n    const res = await clientFetch(`${path}`, {\n        body: stringify({\n            walletSecret: args.walletSecret,\n        }),\n        headers: {\n            \"Content-Type\": \"application/json\",\n        },\n        method: \"POST\",\n    });\n    if (!res.ok) {\n        const error = await res.text();\n        throw new Error(`Failed to generate backend account: ${error}`);\n    }\n    return (await res.json());\n}\n//# sourceMappingURL=backend.js.map","import { getClientFetch } from \"../../../../utils/fetch.js\";\nimport { stringify } from \"../../../../utils/json.js\";\nimport { randomBytesHex } from \"../../../../utils/random.js\";\nimport { getLoginCallbackUrl } from \"./getLoginPath.js\";\n/**\n * Does no real authentication, just issues a temporary token for the user.\n * @internal\n */\nexport async function guestAuthenticate(args) {\n    let sessionId = await args.storage.getGuestSessionId();\n    if (!sessionId) {\n        sessionId = randomBytesHex(32);\n        args.storage.saveGuestSessionId(sessionId);\n    }\n    const clientFetch = getClientFetch(args.client, args.ecosystem);\n    const path = getLoginCallbackUrl({\n        authOption: \"guest\",\n        client: args.client,\n        ecosystem: args.ecosystem,\n    });\n    const res = await clientFetch(`${path}`, {\n        body: stringify({\n            sessionId,\n        }),\n        headers: {\n            \"Content-Type\": \"application/json\",\n        },\n        method: \"POST\",\n    });\n    if (!res.ok) {\n        const error = await res.text();\n        throw new Error(`Failed to generate guest account: ${res.status} ${res.statusText} ${error}`);\n    }\n    return (await res.json());\n}\n//# sourceMappingURL=guest.js.map","import { getClientFetch } from \"../../../../utils/fetch.js\";\nimport { stringify } from \"../../../../utils/json.js\";\nimport { ROUTE_AUTH_JWT_CALLBACK } from \"../../native/helpers/constants.js\";\nimport { createErrorMessage } from \"../../native/helpers/errors.js\";\nexport async function customJwt(args) {\n    const clientFetch = getClientFetch(args.client, args.ecosystem);\n    const res = await clientFetch(ROUTE_AUTH_JWT_CALLBACK, {\n        body: stringify({\n            developerClientId: args.client.clientId,\n            jwt: args.jwt,\n        }),\n        headers: {\n            \"Content-Type\": \"application/json\",\n        },\n        method: \"POST\",\n    });\n    if (!res.ok) {\n        const error = await res.json();\n        throw new Error(`JWT authentication error: ${error.message}`);\n    }\n    try {\n        const { verifiedToken } = await res.json();\n        return { storedToken: verifiedToken };\n    }\n    catch (e) {\n        throw new Error(createErrorMessage(\"Malformed response from post jwt authentication\", e));\n    }\n}\n//# sourceMappingURL=jwt.js.map","import { getThirdwebBaseUrl } from \"../../../../utils/domains.js\";\nimport { getClientFetch } from \"../../../../utils/fetch.js\";\nimport { stringify } from \"../../../../utils/json.js\";\n/**\n * Links a new account to the current one using an auth token.\n * For the public-facing API, use `wallet.linkProfile` instead.\n *\n * @internal\n */\nexport async function linkAccount({ client, ecosystem, tokenToLink, storage, }) {\n    const clientFetch = getClientFetch(client, ecosystem);\n    const IN_APP_URL = getThirdwebBaseUrl(\"inAppWallet\");\n    const currentAccountToken = await storage.getAuthCookie();\n    if (!currentAccountToken) {\n        throw new Error(\"Failed to link account, no user logged in\");\n    }\n    const headers = {\n        Authorization: `Bearer iaw-auth-token:${currentAccountToken}`,\n        \"Content-Type\": \"application/json\",\n    };\n    const linkedDetailsResp = await clientFetch(`${IN_APP_URL}/api/2024-05-05/account/connect`, {\n        body: stringify({\n            accountAuthTokenToConnect: tokenToLink,\n        }),\n        headers,\n        method: \"POST\",\n    });\n    if (!linkedDetailsResp.ok) {\n        const body = await linkedDetailsResp.json();\n        throw new Error(body.message || \"Failed to link account.\");\n    }\n    const { linkedAccounts } = await linkedDetailsResp.json();\n    return (linkedAccounts ?? []);\n}\n/**\n * Links a new account to the current one using an auth token.\n * For the public-facing API, use `wallet.linkProfile` instead.\n *\n * @internal\n */\nexport async function unlinkAccount({ client, ecosystem, profileToUnlink, allowAccountDeletion = false, storage, }) {\n    const clientFetch = getClientFetch(client, ecosystem);\n    const IN_APP_URL = getThirdwebBaseUrl(\"inAppWallet\");\n    const currentAccountToken = await storage.getAuthCookie();\n    if (!currentAccountToken) {\n        throw new Error(\"Failed to unlink account, no user logged in\");\n    }\n    const headers = {\n        Authorization: `Bearer iaw-auth-token:${currentAccountToken}`,\n        \"Content-Type\": \"application/json\",\n    };\n    const linkedDetailsResp = await clientFetch(`${IN_APP_URL}/api/2024-05-05/account/disconnect`, {\n        body: stringify({\n            allowAccountDeletion,\n            details: profileToUnlink.details,\n            type: profileToUnlink.type,\n        }),\n        headers,\n        method: \"POST\",\n    });\n    if (!linkedDetailsResp.ok) {\n        const body = await linkedDetailsResp.json();\n        throw new Error(body.message || \"Failed to unlink account.\");\n    }\n    const { linkedAccounts } = await linkedDetailsResp.json();\n    return (linkedAccounts ?? []);\n}\n/**\n * Gets the linked accounts for the current user.\n * For the public-facing API, use `wallet.getProfiles` instead.\n *\n * @internal\n */\nexport async function getLinkedProfilesInternal({ client, ecosystem, storage, }) {\n    const clientFetch = getClientFetch(client, ecosystem);\n    const IN_APP_URL = getThirdwebBaseUrl(\"inAppWallet\");\n    const currentAccountToken = await storage.getAuthCookie();\n    if (!currentAccountToken) {\n        throw new Error(\"Failed to get linked accounts, no user logged in\");\n    }\n    const headers = {\n        Authorization: `Bearer iaw-auth-token:${currentAccountToken}`,\n        \"Content-Type\": \"application/json\",\n    };\n    const linkedAccountsResp = await clientFetch(`${IN_APP_URL}/api/2024-05-05/accounts`, {\n        headers,\n        method: \"GET\",\n    });\n    if (!linkedAccountsResp.ok) {\n        const body = await linkedAccountsResp.json();\n        throw new Error(body.message || \"Failed to get linked accounts.\");\n    }\n    const { linkedAccounts } = await linkedAccountsResp.json();\n    return (linkedAccounts ?? []);\n}\n//# sourceMappingURL=linkAccount.js.map","import { getThirdwebBaseUrl } from \"../../../../utils/domains.js\";\nimport { getClientFetch } from \"../../../../utils/fetch.js\";\nimport { stringify } from \"../../../../utils/json.js\";\nfunction getVerificationPath() {\n    return `${getThirdwebBaseUrl(\"inAppWallet\")}/api/2024-05-05/login/passkey/callback`;\n}\nfunction getChallengePath(type, username) {\n    return `${getThirdwebBaseUrl(\"inAppWallet\")}/api/2024-05-05/login/passkey?type=${type}${username ? `&username=${username}` : \"\"}`;\n}\nexport async function registerPasskey(options) {\n    if (!options.passkeyClient.isAvailable()) {\n        throw new Error(\"Passkeys are not available on this device\");\n    }\n    const fetchWithId = getClientFetch(options.client, options.ecosystem);\n    const generatedName = options.username ?? generateUsername(options.ecosystem);\n    // 1. request challenge from  server\n    const res = await fetchWithId(getChallengePath(\"sign-up\", generatedName));\n    const challengeData = await res.json();\n    if (!challengeData.challenge) {\n        throw new Error(\"No challenge received\");\n    }\n    const challenge = challengeData.challenge;\n    // 2. initiate registration\n    const registration = await options.passkeyClient.register({\n        challenge,\n        name: generatedName,\n        rp: options.rp,\n    });\n    const customHeaders = {};\n    if (options.ecosystem?.partnerId) {\n        customHeaders[\"x-ecosystem-partner-id\"] = options.ecosystem.partnerId;\n    }\n    if (options.ecosystem?.id) {\n        customHeaders[\"x-ecosystem-id\"] = options.ecosystem.id;\n    }\n    // 3. send the registration object to the server\n    const verifRes = await fetchWithId(getVerificationPath(), {\n        body: stringify({\n            authenticatorData: registration.authenticatorData,\n            clientData: registration.clientData,\n            credential: {\n                algorithm: registration.credential.algorithm,\n                publicKey: registration.credential.publicKey,\n            },\n            credentialId: registration.credentialId,\n            origin: registration.origin,\n            rpId: options.rp.id,\n            serverVerificationId: challengeData.serverVerificationId,\n            type: \"sign-up\",\n            username: generatedName,\n        }),\n        headers: {\n            \"Content-Type\": \"application/json\",\n            ...customHeaders,\n        },\n        method: \"POST\",\n    });\n    const verifData = await verifRes.json();\n    if (!verifData || !verifData.storedToken) {\n        throw new Error(`Error verifying passkey: ${verifData.message ?? \"unknown error\"}`);\n    }\n    // 4. store the credentialId in local storage\n    await options.storage?.savePasskeyCredentialId(registration.credentialId);\n    // 5. returns back the IAW authentication token\n    return verifData;\n}\nexport async function loginWithPasskey(options) {\n    if (!options.passkeyClient.isAvailable()) {\n        throw new Error(\"Passkeys are not available on this device\");\n    }\n    const fetchWithId = getClientFetch(options.client, options.ecosystem);\n    // 1. request challenge from  server/iframe\n    const [challengeData, credentialId] = await Promise.all([\n        fetchWithId(getChallengePath(\"sign-in\")).then((r) => r.json()),\n        options.storage?.getPasskeyCredentialId(),\n    ]);\n    if (!challengeData.challenge) {\n        throw new Error(\"No challenge received\");\n    }\n    const challenge = challengeData.challenge;\n    // 2. initiate login\n    const authentication = await options.passkeyClient.authenticate({\n        challenge,\n        credentialId: credentialId ?? undefined,\n        rp: options.rp,\n    });\n    const customHeaders = {};\n    if (options.ecosystem?.partnerId) {\n        customHeaders[\"x-ecosystem-partner-id\"] = options.ecosystem.partnerId;\n    }\n    if (options.ecosystem?.id) {\n        customHeaders[\"x-ecosystem-id\"] = options.ecosystem.id;\n    }\n    const verifRes = await fetchWithId(getVerificationPath(), {\n        body: stringify({\n            authenticatorData: authentication.authenticatorData,\n            clientData: authentication.clientData,\n            credentialId: authentication.credentialId,\n            origin: authentication.origin,\n            rpId: options.rp.id,\n            serverVerificationId: challengeData.serverVerificationId,\n            signature: authentication.signature,\n            type: \"sign-in\",\n        }),\n        headers: {\n            \"Content-Type\": \"application/json\",\n            ...customHeaders,\n        },\n        method: \"POST\",\n    });\n    const verifData = await verifRes.json();\n    if (!verifData || !verifData.storedToken) {\n        throw new Error(`Error verifying passkey: ${verifData.message ?? \"unknown error\"}`);\n    }\n    // 5. store the credentialId in local storage\n    await options.storage?.savePasskeyCredentialId(authentication.credentialId);\n    // 6. return the auth'd user type\n    return verifData;\n}\nfunction generateUsername(ecosystem) {\n    return `${ecosystem?.id ?? \"wallet\"}-${new Date().toISOString()}`;\n}\n//# sourceMappingURL=passkeys.js.map","import { signLoginPayload } from \"../../../../auth/core/sign-login-payload.js\";\nimport { getCachedChain } from \"../../../../chains/utils.js\";\nimport { getClientFetch } from \"../../../../utils/fetch.js\";\nimport { stringify } from \"../../../../utils/json.js\";\nimport { getLoginCallbackUrl, getLoginUrl } from \"./getLoginPath.js\";\n// wallets that cannot sign with ethereum mainnet, require a specific chain always\nconst NON_ETHEREUM_WALLETS = [\"xyz.abs\"];\n/**\n * @internal\n */\nexport async function siweAuthenticate(args) {\n    const { wallet, client, ecosystem, chain } = args;\n    const siweChain = NON_ETHEREUM_WALLETS.includes(wallet.id)\n        ? chain || getCachedChain(1)\n        : getCachedChain(1); // fallback to mainnet for SIWE for wide wallet compatibility\n    // only connect if the wallet doesn't alnready have an account\n    const account = wallet.getAccount() || (await wallet.connect({ chain: siweChain, client }));\n    const clientFetch = getClientFetch(client, ecosystem);\n    const payload = await (async () => {\n        const path = getLoginUrl({\n            authOption: \"wallet\",\n            client: args.client,\n            ecosystem: args.ecosystem,\n        });\n        const res = await clientFetch(`${path}&address=${account.address}&chainId=${siweChain.id}`);\n        if (!res.ok)\n            throw new Error(\"Failed to generate SIWE login payload\");\n        return (await res.json());\n    })();\n    const { signature } = await signLoginPayload({ account, payload });\n    const authResult = await (async () => {\n        const path = getLoginCallbackUrl({\n            authOption: \"wallet\",\n            client: args.client,\n            ecosystem: args.ecosystem,\n        });\n        const res = await clientFetch(`${path}&signature=${signature}&payload=${encodeURIComponent(payload)}`, {\n            body: stringify({\n                payload,\n                signature,\n            }),\n            headers: {\n                \"Content-Type\": \"application/json\",\n            },\n            method: \"POST\",\n        });\n        if (!res.ok)\n            throw new Error(\"Failed to verify SIWE signature\");\n        return (await res.json());\n    })();\n    return authResult;\n}\n//# sourceMappingURL=siwe.js.map","import { getThirdwebBaseUrl } from \"../../../../utils/domains.js\";\nimport { getClientFetch } from \"../../../../utils/fetch.js\";\nimport { stringify } from \"../../../../utils/json.js\";\nexport async function signAuthorization({ client, payload, storage, }) {\n    const authToken = await storage.getAuthCookie();\n    const ecosystem = storage.ecosystem;\n    const clientFetch = getClientFetch(client, ecosystem);\n    if (!authToken) {\n        throw new Error(\"No auth token found when signing message\");\n    }\n    const body = {\n        address: payload.address,\n        chainId: payload.chainId,\n        nonce: Number(payload.nonce),\n    };\n    const response = await clientFetch(`${getThirdwebBaseUrl(\"inAppWallet\")}/api/v1/enclave-wallet/sign-authorization`, {\n        body: stringify(body),\n        headers: {\n            Authorization: `Bearer embedded-wallet-token:${authToken}`,\n            \"Content-Type\": \"application/json\",\n            \"x-thirdweb-client-id\": client.clientId,\n        },\n        method: \"POST\",\n    });\n    if (!response.ok) {\n        throw new Error(`Failed to sign message - ${response.status} ${response.statusText}`);\n    }\n    const signedAuthorization = (await response.json());\n    return signedAuthorization;\n}\n//# sourceMappingURL=sign-authorization.enclave.js.map","import { getThirdwebBaseUrl } from \"../../../../utils/domains.js\";\nimport { getClientFetch } from \"../../../../utils/fetch.js\";\nimport { stringify } from \"../../../../utils/json.js\";\nexport async function signMessage({ client, payload: { message, isRaw, originalMessage, chainId }, storage, }) {\n    const authToken = await storage.getAuthCookie();\n    const ecosystem = storage.ecosystem;\n    const clientFetch = getClientFetch(client, ecosystem);\n    if (!authToken) {\n        throw new Error(\"No auth token found when signing message\");\n    }\n    const response = await clientFetch(`${getThirdwebBaseUrl(\"inAppWallet\")}/api/v1/enclave-wallet/sign-message`, {\n        body: stringify({\n            messagePayload: {\n                chainId,\n                isRaw,\n                message,\n                originalMessage,\n            },\n        }),\n        headers: {\n            Authorization: `Bearer embedded-wallet-token:${authToken}`,\n            \"Content-Type\": \"application/json\",\n            \"x-thirdweb-client-id\": client.clientId,\n        },\n        method: \"POST\",\n    });\n    if (!response.ok) {\n        throw new Error(`Failed to sign message - ${response.status} ${response.statusText}`);\n    }\n    const signedMessage = (await response.json());\n    return signedMessage;\n}\n//# sourceMappingURL=sign-message.enclave.js.map","import { getThirdwebBaseUrl } from \"../../../../utils/domains.js\";\nimport { getClientFetch } from \"../../../../utils/fetch.js\";\nimport { stringify } from \"../../../../utils/json.js\";\nexport async function signTransaction({ client, payload, storage, }) {\n    const authToken = await storage.getAuthCookie();\n    const ecosystem = storage.ecosystem;\n    const clientFetch = getClientFetch(client, ecosystem);\n    if (!authToken) {\n        throw new Error(\"No auth token found when signing transaction\");\n    }\n    const response = await clientFetch(`${getThirdwebBaseUrl(\"inAppWallet\")}/api/v1/enclave-wallet/sign-transaction`, {\n        body: stringify({\n            transactionPayload: payload,\n        }),\n        headers: {\n            Authorization: `Bearer embedded-wallet-token:${authToken}`,\n            \"Content-Type\": \"application/json\",\n            \"x-thirdweb-client-id\": client.clientId,\n        },\n        method: \"POST\",\n    });\n    if (!response.ok) {\n        throw new Error(`Failed to sign transaction - ${response.status} ${response.statusText}`);\n    }\n    const signedTransaction = (await response.json());\n    return signedTransaction.signature;\n}\n//# sourceMappingURL=sign-transaction.enclave.js.map","import { getThirdwebBaseUrl } from \"../../../../utils/domains.js\";\nimport { getClientFetch } from \"../../../../utils/fetch.js\";\nimport { stringify } from \"../../../../utils/json.js\";\nexport async function signTypedData({ client, payload, storage, }) {\n    const authToken = await storage.getAuthCookie();\n    const ecosystem = storage.ecosystem;\n    const clientFetch = getClientFetch(client, ecosystem);\n    if (!authToken) {\n        throw new Error(\"No auth token found when signing typed data\");\n    }\n    const response = await clientFetch(`${getThirdwebBaseUrl(\"inAppWallet\")}/api/v1/enclave-wallet/sign-typed-data`, {\n        body: stringify({\n            ...payload,\n        }),\n        headers: {\n            Authorization: `Bearer embedded-wallet-token:${authToken}`,\n            \"Content-Type\": \"application/json\",\n            \"x-thirdweb-client-id\": client.clientId,\n        },\n        method: \"POST\",\n    });\n    if (!response.ok) {\n        throw new Error(`Failed to sign typed data - ${response.status} ${response.statusText}`);\n    }\n    const signedTypedData = (await response.json());\n    return signedTypedData;\n}\n//# sourceMappingURL=sign-typed-data.enclave.js.map","import { bytesToHex } from \"viem\";\nimport { trackTransaction } from \"../../../../analytics/track/transaction.js\";\nimport { getCachedChain } from \"../../../../chains/utils.js\";\nimport { eth_sendRawTransaction } from \"../../../../rpc/actions/eth_sendRawTransaction.js\";\nimport { getRpcClient } from \"../../../../rpc/rpc.js\";\nimport { getAddress } from \"../../../../utils/address.js\";\nimport { isHex, toHex } from \"../../../../utils/encoding/hex.js\";\nimport { parseTypedData } from \"../../../../utils/signatures/helpers/parse-typed-data.js\";\nimport { getUserStatus } from \"../actions/get-enclave-user-status.js\";\nimport { signAuthorization as signEnclaveAuthorization } from \"../actions/sign-authorization.enclave.js\";\nimport { signMessage as signEnclaveMessage } from \"../actions/sign-message.enclave.js\";\nimport { signTransaction as signEnclaveTransaction } from \"../actions/sign-transaction.enclave.js\";\nimport { signTypedData as signEnclaveTypedData } from \"../actions/sign-typed-data.enclave.js\";\nexport class EnclaveWallet {\n    constructor({ client, ecosystem, address, storage, }) {\n        Object.defineProperty(this, \"client\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"ecosystem\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"address\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"localStorage\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.client = client;\n        this.ecosystem = ecosystem;\n        this.address = address;\n        this.localStorage = storage;\n    }\n    /**\n     * Store the auth token for use\n     * @returns `{walletAddress: string }` The user's wallet details\n     * @internal\n     */\n    async postWalletSetUp(authResult) {\n        await this.localStorage.saveAuthCookie(authResult.storedToken.cookieString);\n    }\n    /**\n     * Gets the current user's details\n     * @internal\n     */\n    async getUserWalletStatus() {\n        const token = await this.localStorage.getAuthCookie();\n        if (!token) {\n            return { status: \"Logged Out\" };\n        }\n        const userStatus = await getUserStatus({\n            authToken: token,\n            client: this.client,\n            ecosystem: this.ecosystem,\n        });\n        if (!userStatus) {\n            return { status: \"Logged Out\" };\n        }\n        const wallet = userStatus.wallets[0];\n        const authDetails = {\n            email: userStatus.linkedAccounts.find((account) => account.details.email !== undefined)?.details.email,\n            phoneNumber: userStatus.linkedAccounts.find((account) => account.details.phone !== undefined)?.details.phone,\n            recoveryShareManagement: \"ENCLAVE\",\n            userWalletId: userStatus.id || \"\",\n        };\n        if (!wallet) {\n            return {\n                authDetails,\n                status: \"Logged In, Wallet Uninitialized\",\n            };\n        }\n        return {\n            account: await this.getAccount(),\n            authDetails,\n            status: \"Logged In, Wallet Initialized\",\n            walletAddress: wallet.address,\n        };\n    }\n    /**\n     * Returns an account to perform wallet operations\n     * @internal\n     */\n    async getAccount() {\n        const client = this.client;\n        const storage = this.localStorage;\n        const address = this.address;\n        const ecosystem = this.ecosystem;\n        const _signTransaction = async (tx) => {\n            const rpcRequest = getRpcClient({\n                chain: getCachedChain(tx.chainId),\n                client,\n            });\n            const transaction = {\n                chainId: toHex(tx.chainId),\n                data: tx.data,\n                gas: hexlify(tx.gas),\n                nonce: hexlify(tx.nonce) ||\n                    toHex(await import(\"../../../../rpc/actions/eth_getTransactionCount.js\").then(({ eth_getTransactionCount }) => eth_getTransactionCount(rpcRequest, {\n                        address: getAddress(this.address),\n                        blockTag: \"pending\",\n                    }))),\n                to: tx.to ? getAddress(tx.to) : undefined,\n                value: hexlify(tx.value),\n            };\n            if (tx.authorizationList && tx.authorizationList.length > 0) {\n                transaction.type = 4;\n                transaction.authorizationList = tx.authorizationList;\n                transaction.maxFeePerGas = hexlify(tx.maxFeePerGas);\n                transaction.maxPriorityFeePerGas = hexlify(tx.maxPriorityFeePerGas);\n            }\n            else if (hexlify(tx.maxFeePerGas)) {\n                transaction.maxFeePerGas = hexlify(tx.maxFeePerGas);\n                transaction.maxPriorityFeePerGas = hexlify(tx.maxPriorityFeePerGas);\n                transaction.type = 2;\n            }\n            else {\n                transaction.gasPrice = hexlify(tx.gasPrice);\n                transaction.type = 0;\n            }\n            return signEnclaveTransaction({\n                client,\n                payload: transaction,\n                storage,\n            });\n        };\n        const account = {\n            address: getAddress(address),\n            async sendTransaction(tx) {\n                const rpcRequest = getRpcClient({\n                    chain: getCachedChain(tx.chainId),\n                    client,\n                });\n                const signedTx = await _signTransaction(tx);\n                const transactionHash = await eth_sendRawTransaction(rpcRequest, signedTx);\n                trackTransaction({\n                    chainId: tx.chainId,\n                    client,\n                    contractAddress: tx.to ?? undefined,\n                    ecosystem,\n                    gasPrice: tx.gasPrice,\n                    transactionHash,\n                    walletAddress: address,\n                    walletType: \"inApp\",\n                });\n                return { transactionHash };\n            },\n            async signAuthorization(payload) {\n                const authorization = await signEnclaveAuthorization({\n                    client,\n                    payload,\n                    storage,\n                });\n                return {\n                    address: getAddress(authorization.address),\n                    chainId: Number.parseInt(authorization.chainId),\n                    nonce: BigInt(authorization.nonce),\n                    r: BigInt(authorization.r),\n                    s: BigInt(authorization.s),\n                    yParity: Number.parseInt(authorization.yParity),\n                };\n            },\n            async signMessage({ message, originalMessage, chainId }) {\n                const messagePayload = (() => {\n                    if (typeof message === \"string\") {\n                        return { chainId, isRaw: false, message, originalMessage };\n                    }\n                    return {\n                        chainId,\n                        isRaw: true,\n                        message: typeof message.raw === \"string\"\n                            ? message.raw\n                            : bytesToHex(message.raw),\n                        originalMessage,\n                    };\n                })();\n                const { signature } = await signEnclaveMessage({\n                    client,\n                    payload: messagePayload,\n                    storage,\n                });\n                return signature;\n            },\n            async signTransaction(tx) {\n                if (!tx.chainId) {\n                    throw new Error(\"chainId required in tx to sign\");\n                }\n                return _signTransaction({\n                    chainId: tx.chainId,\n                    ...tx,\n                });\n            },\n            async signTypedData(_typedData) {\n                const parsedTypedData = parseTypedData(_typedData);\n                const { signature } = await signEnclaveTypedData({\n                    client,\n                    payload: parsedTypedData,\n                    storage,\n                });\n                return signature;\n            },\n            sendCalls: async (options) => {\n                const { inAppWalletSendCalls } = await import(\"../eip5792/in-app-wallet-calls.js\");\n                const firstCall = options.calls[0];\n                if (!firstCall) {\n                    throw new Error(\"No calls to send\");\n                }\n                const client = firstCall.client;\n                const chain = firstCall.chain || options.chain;\n                const id = await inAppWalletSendCalls({\n                    account: account,\n                    calls: options.calls,\n                    chain,\n                });\n                return { chain, client, id };\n            },\n            getCallsStatus: async (options) => {\n                const { inAppWalletGetCallsStatus } = await import(\"../eip5792/in-app-wallet-calls.js\");\n                return inAppWalletGetCallsStatus(options);\n            },\n            getCapabilities: async (options) => {\n                return {\n                    [options.chainId ?? 1]: {\n                        atomic: {\n                            status: \"unsupported\",\n                        },\n                        paymasterService: {\n                            supported: false,\n                        },\n                    },\n                };\n            },\n        };\n        return account;\n    }\n}\nfunction hexlify(value) {\n    return value === undefined || isHex(value) ? value : toHex(value);\n}\n//# sourceMappingURL=enclave-wallet.js.map","import { sleep } from \"../../../../../utils/sleep.js\";\nconst iframeBaseStyle = {\n    backgroundColor: \"transparent\",\n    border: \"none\",\n    colorScheme: \"light\",\n    display: \"none\",\n    height: \"100%\",\n    pointerEvents: \"all\",\n    position: \"fixed\",\n    right: \"0px\",\n    top: \"0px\",\n    width: \"100%\",\n    zIndex: \"2147483646\",\n};\n// Global var to help track iframe state\nconst isIframeLoaded = new Map();\n/**\n * @internal\n */\n// biome-ignore lint/suspicious/noExplicitAny: TODO: fix later\nexport class IframeCommunicator {\n    /**\n     * @internal\n     */\n    constructor({ link, baseUrl, iframeId, container, onIframeInitialize, localStorage, clientId, ecosystem, }) {\n        Object.defineProperty(this, \"iframe\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"POLLING_INTERVAL_SECONDS\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 1.4\n        });\n        Object.defineProperty(this, \"iframeBaseUrl\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"localStorage\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"clientId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"ecosystem\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.localStorage = localStorage;\n        this.clientId = clientId;\n        this.ecosystem = ecosystem;\n        this.iframeBaseUrl = baseUrl;\n        if (typeof document === \"undefined\") {\n            return;\n        }\n        container = container ?? document.body;\n        // Creating the IFrame element for communication\n        let iframe = document.getElementById(iframeId);\n        const hrefLink = new URL(link);\n        // TODO (ew) - bring back version tracking\n        // const sdkVersion = process.env.THIRDWEB_EWS_SDK_VERSION;\n        // if (!sdkVersion) {\n        //   throw new Error(\"Missing THIRDWEB_EWS_SDK_VERSION env var\");\n        // }\n        // hrefLink.searchParams.set(\"sdkVersion\", sdkVersion);\n        if (!iframe || iframe.src !== hrefLink.href) {\n            // ! Do not update the hrefLink here or it'll cause multiple re-renders\n            iframe = document.createElement(\"iframe\");\n            const mergedIframeStyles = {\n                ...iframeBaseStyle,\n            };\n            Object.assign(iframe.style, mergedIframeStyles);\n            iframe.setAttribute(\"id\", iframeId);\n            iframe.setAttribute(\"fetchpriority\", \"high\");\n            container.appendChild(iframe);\n            iframe.src = hrefLink.href;\n            // iframe.setAttribute(\"data-version\", sdkVersion);\n            // biome-ignore lint/suspicious/noExplicitAny: TODO: fix later\n            const onIframeLoaded = (event) => {\n                if (event.data.eventType === \"ewsIframeLoaded\") {\n                    window.removeEventListener(\"message\", onIframeLoaded);\n                    if (!iframe) {\n                        console.warn(\"thirdweb iFrame not found\");\n                        return;\n                    }\n                    this.onIframeLoadHandler(iframe, onIframeInitialize)();\n                }\n            };\n            window.addEventListener(\"message\", onIframeLoaded);\n        }\n        this.iframe = iframe;\n    }\n    // biome-ignore lint/suspicious/noExplicitAny: TODO: fix later\n    async onIframeLoadedInitVariables() {\n        return {\n            authCookie: await this.localStorage.getAuthCookie(),\n            clientId: this.clientId,\n            deviceShareStored: await this.localStorage.getDeviceShare(),\n            ecosystemId: this.ecosystem?.id,\n            partnerId: this.ecosystem?.partnerId,\n            walletUserId: await this.localStorage.getWalletUserId(),\n        };\n    }\n    /**\n     * @internal\n     */\n    onIframeLoadHandler(iframe, onIframeInitialize) {\n        return async () => {\n            const channel = new MessageChannel();\n            const promise = new Promise((res, rej) => {\n                // biome-ignore lint/suspicious/noExplicitAny: TODO: fix later\n                channel.port1.onmessage = (event) => {\n                    const { data } = event;\n                    channel.port1.close();\n                    if (!data.success) {\n                        rej(new Error(data.error));\n                    }\n                    isIframeLoaded.set(iframe.src, true);\n                    if (onIframeInitialize) {\n                        onIframeInitialize();\n                    }\n                    res(true);\n                };\n            });\n            iframe?.contentWindow?.postMessage({\n                data: await this.onIframeLoadedInitVariables(),\n                eventType: \"initIframe\",\n            }, this.iframeBaseUrl, [channel.port2]);\n            await promise;\n        };\n    }\n    /**\n     * @internal\n     */\n    async call({ procedureName, params, showIframe = false, }) {\n        if (!this.iframe) {\n            throw new Error(\"Iframe not found. You are likely calling this from the backend where the DOM is not available.\");\n        }\n        while (!isIframeLoaded.get(this.iframe.src)) {\n            await sleep(this.POLLING_INTERVAL_SECONDS * 1000);\n        }\n        if (showIframe) {\n            this.iframe.style.display = \"block\";\n            // magic number to let the display render before performing the animation of the modal in\n            await sleep(0.005 * 1000);\n        }\n        const channel = new MessageChannel();\n        const promise = new Promise((res, rej) => {\n            // biome-ignore lint/suspicious/noExplicitAny: TODO: fix later\n            channel.port1.onmessage = async (event) => {\n                const { data } = event;\n                channel.port1.close();\n                if (showIframe) {\n                    // magic number to let modal fade out before hiding it\n                    await sleep(0.1 * 1000);\n                    if (this.iframe) {\n                        this.iframe.style.display = \"none\";\n                    }\n                }\n                if (!data.success) {\n                    rej(new Error(data.error));\n                }\n                else {\n                    res(data.data);\n                }\n            };\n        });\n        this.iframe.contentWindow?.postMessage({\n            // Pass the initialization data on every request in case the iframe storage was reset (can happen in some environments such as iOS PWAs)\n            data: {\n                ...params,\n                ...(await this.onIframeLoadedInitVariables()),\n            },\n            eventType: procedureName,\n        }, this.iframeBaseUrl, [channel.port2]);\n        return promise;\n    }\n    /**\n     * This has to be called by any iframe that will be removed from the DOM.\n     * Use to make sure that we reset the global loaded state of the particular iframe.src\n     * @internal\n     */\n    destroy() {\n        if (this.iframe) {\n            isIframeLoaded.delete(this.iframe.src);\n        }\n    }\n}\n//# sourceMappingURL=IframeCommunicator.js.map","import { webLocalStorage } from \"../../../../../utils/storage/webStorage.js\";\nimport { ClientScopedStorage } from \"../../../core/authentication/client-scoped-storage.js\";\nimport { IN_APP_WALLET_PATH } from \"../../../core/constants/settings.js\";\nimport { IframeCommunicator } from \"./IframeCommunicator.js\";\n/**\n * @internal\n */\nexport class InAppWalletIframeCommunicator extends IframeCommunicator {\n    /**\n     * @internal\n     */\n    constructor({ clientId, baseUrl, ecosystem, }) {\n        super({\n            baseUrl,\n            clientId,\n            container: typeof document === \"undefined\" ? undefined : document.body,\n            ecosystem,\n            iframeId: IN_APP_WALLET_IFRAME_ID + (ecosystem?.id || \"\"),\n            link: createInAppWalletIframeLink({\n                baseUrl,\n                clientId,\n                ecosystem,\n                path: IN_APP_WALLET_PATH,\n            }).href,\n            localStorage: new ClientScopedStorage({\n                clientId,\n                ecosystem,\n                storage: webLocalStorage,\n            }),\n        });\n        this.clientId = clientId;\n        this.ecosystem = ecosystem;\n    }\n}\n// This is the URL and ID tag of the iFrame that we communicate with\n/**\n * @internal\n */\nfunction createInAppWalletIframeLink({ clientId, baseUrl, path, ecosystem, queryParams, }) {\n    const inAppWalletUrl = new URL(`${path}`, baseUrl);\n    if (queryParams) {\n        for (const queryKey of Object.keys(queryParams)) {\n            inAppWalletUrl.searchParams.set(queryKey, queryParams[queryKey]?.toString() || \"\");\n        }\n    }\n    inAppWalletUrl.searchParams.set(\"clientId\", clientId);\n    if (ecosystem?.partnerId !== undefined) {\n        inAppWalletUrl.searchParams.set(\"partnerId\", ecosystem.partnerId);\n    }\n    if (ecosystem?.id !== undefined) {\n        inAppWalletUrl.searchParams.set(\"ecosystemId\", ecosystem.id);\n    }\n    return inAppWalletUrl;\n}\nconst IN_APP_WALLET_IFRAME_ID = \"thirdweb-in-app-wallet-iframe\";\n//# sourceMappingURL=InAppWalletIframeCommunicator.js.map","import { getThirdwebBaseUrl } from \"../../../../utils/domains.js\";\nimport { getClientFetch } from \"../../../../utils/fetch.js\";\n/**\n * Generate a new enclave wallet using an auth token\n * @internal\n */\nexport async function generateWallet({ client, ecosystem, authToken, }) {\n    const clientFetch = getClientFetch(client, ecosystem);\n    const response = await clientFetch(`${getThirdwebBaseUrl(\"inAppWallet\")}/api/v1/enclave-wallet/generate`, {\n        headers: {\n            Authorization: `Bearer embedded-wallet-token:${authToken}`,\n            \"Content-Type\": \"application/json\",\n            \"x-thirdweb-client-id\": client.clientId,\n        },\n        method: \"POST\",\n    });\n    if (!response.ok) {\n        throw new Error(`Failed to generate wallet - ${response.status} ${response.statusText}`);\n    }\n    const { wallet } = (await response.json());\n    return wallet;\n}\n//# sourceMappingURL=generate-wallet.enclave.js.map","/**\n * @internal\n */\nexport class AbstractLogin {\n    /**\n     * Used to manage the user's auth states. This should not be instantiated directly.\n     * @internal\n     */\n    constructor({ baseUrl, querier, preLogin, postLogin, client, ecosystem, }) {\n        Object.defineProperty(this, \"LoginQuerier\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"preLogin\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"postLogin\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"client\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"baseUrl\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"ecosystem\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.baseUrl = baseUrl;\n        this.LoginQuerier = querier;\n        this.preLogin = preLogin;\n        this.postLogin = postLogin;\n        this.client = client;\n        this.ecosystem = ecosystem;\n    }\n    /**\n     * @internal\n     */\n    async sendEmailLoginOtp({ email, }) {\n        const result = await this.LoginQuerier.call({\n            params: { email },\n            procedureName: \"sendThirdwebEmailLoginOtp\",\n        });\n        return result;\n    }\n    /**\n     *\n     * @internal\n     */\n    async sendSmsLoginOtp({ phoneNumber, }) {\n        const result = await this.LoginQuerier.call({\n            params: { phoneNumber },\n            procedureName: \"sendThirdwebSmsLoginOtp\",\n        });\n        return result;\n    }\n}\n//# sourceMappingURL=abstract-login.js.map","import { AbstractLogin } from \"./abstract-login.js\";\n/**\n *\n */\nexport class BaseLogin extends AbstractLogin {\n    async authenticateWithModal() {\n        return this.LoginQuerier.call({\n            params: undefined,\n            procedureName: \"loginWithThirdwebModal\",\n            showIframe: true,\n        });\n    }\n    /**\n     * @internal\n     */\n    async loginWithModal() {\n        await this.preLogin();\n        const result = await this.authenticateWithModal();\n        return this.postLogin(result);\n    }\n    async authenticateWithIframe({ email, }) {\n        return this.LoginQuerier.call({\n            params: { email },\n            procedureName: \"loginWithThirdwebModal\",\n            showIframe: true,\n        });\n    }\n    /**\n     * @internal\n     */\n    async loginWithIframe({ email, }) {\n        await this.preLogin();\n        const result = await this.authenticateWithIframe({ email });\n        return this.postLogin(result);\n    }\n    async authenticateWithCustomJwt({ encryptionKey, jwt, }) {\n        if (!encryptionKey || encryptionKey.length === 0) {\n            throw new Error(\"Encryption key is required for custom jwt auth\");\n        }\n        return this.LoginQuerier.call({\n            params: { encryptionKey, jwt },\n            procedureName: \"loginWithCustomJwt\",\n        });\n    }\n    /**\n     * @internal\n     */\n    async loginWithCustomJwt({ encryptionKey, jwt, }) {\n        if (!encryptionKey || encryptionKey.length === 0) {\n            throw new Error(\"Encryption key is required for custom jwt auth\");\n        }\n        await this.preLogin();\n        const result = await this.authenticateWithCustomJwt({ encryptionKey, jwt });\n        return this.postLogin(result);\n    }\n    async authenticateWithCustomAuthEndpoint({ encryptionKey, payload, }) {\n        return this.LoginQuerier.call({\n            params: { encryptionKey, payload },\n            procedureName: \"loginWithCustomAuthEndpoint\",\n        });\n    }\n    /**\n     * @internal\n     */\n    async loginWithCustomAuthEndpoint({ encryptionKey, payload, }) {\n        if (!encryptionKey || encryptionKey.length === 0) {\n            throw new Error(\"Encryption key is required for custom auth\");\n        }\n        await this.preLogin();\n        const result = await this.authenticateWithCustomAuthEndpoint({\n            encryptionKey,\n            payload,\n        });\n        return this.postLogin(result);\n    }\n    async authenticateWithEmailOtp({ email, otp, recoveryCode, }) {\n        return this.LoginQuerier.call({\n            params: { email, otp, recoveryCode },\n            procedureName: \"verifyThirdwebEmailLoginOtp\",\n        });\n    }\n    /**\n     * @internal\n     */\n    async loginWithEmailOtp({ email, otp, recoveryCode, }) {\n        const result = await this.authenticateWithEmailOtp({\n            email,\n            otp,\n            recoveryCode,\n        });\n        return this.postLogin(result);\n    }\n    async authenticateWithSmsOtp({ phoneNumber, otp, recoveryCode, }) {\n        return this.LoginQuerier.call({\n            params: { otp, phoneNumber, recoveryCode },\n            procedureName: \"verifyThirdwebSmsLoginOtp\",\n        });\n    }\n    /**\n     * @internal\n     */\n    async loginWithSmsOtp({ phoneNumber, otp, recoveryCode, }) {\n        const result = await this.authenticateWithSmsOtp({\n            otp,\n            phoneNumber,\n            recoveryCode,\n        });\n        return this.postLogin(result);\n    }\n}\n//# sourceMappingURL=base-login.js.map","import { generateWallet } from \"../../../core/actions/generate-wallet.enclave.js\";\nimport { getUserStatus } from \"../../../core/actions/get-enclave-user-status.js\";\nimport { BaseLogin } from \"./base-login.js\";\n/**\n *\n */\nexport class Auth {\n    /**\n     * Used to manage the user's auth states. This should not be instantiated directly.\n     * @internal\n     */\n    constructor({ client, querier, onAuthSuccess, ecosystem, baseUrl, localStorage, }) {\n        Object.defineProperty(this, \"client\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"ecosystem\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"AuthQuerier\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"localStorage\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"onAuthSuccess\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"BaseLogin\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.client = client;\n        this.ecosystem = ecosystem;\n        this.AuthQuerier = querier;\n        this.localStorage = localStorage;\n        this.onAuthSuccess = onAuthSuccess;\n        this.BaseLogin = new BaseLogin({\n            baseUrl,\n            client,\n            ecosystem,\n            postLogin: async (result) => {\n                return this.postLogin(result);\n            },\n            preLogin: async () => {\n                await this.preLogin();\n            },\n            querier: querier,\n        });\n    }\n    async preLogin() {\n        await this.logout();\n    }\n    async postLogin({ storedToken, walletDetails, }) {\n        if (storedToken.shouldStoreCookieString) {\n            await this.localStorage.saveAuthCookie(storedToken.cookieString);\n        }\n        const initializedUser = await this.onAuthSuccess({\n            storedToken,\n            walletDetails,\n        });\n        return initializedUser;\n    }\n    async loginWithAuthToken(authToken, recoveryCode) {\n        // We don't call logout for backend auth because that is handled on the backend where the iframe isn't available to call. Moreover, logout clears the local storage which isn't applicable for backend auth.\n        if (authToken.storedToken.authProvider !== \"Backend\") {\n            await this.preLogin();\n        }\n        const user = await getUserStatus({\n            authToken: authToken.storedToken.cookieString,\n            client: this.client,\n            ecosystem: this.ecosystem,\n        });\n        if (!user) {\n            throw new Error(\"Cannot login, no user found for auth token\");\n        }\n        // If they're already an enclave wallet, proceed to login\n        if (user.wallets.length > 0 && user.wallets[0]?.type === \"enclave\") {\n            return this.postLogin({\n                storedToken: authToken.storedToken,\n                walletDetails: {\n                    walletAddress: user.wallets[0].address,\n                },\n            });\n        }\n        if (user.wallets.length === 0) {\n            // If this is a new ecosystem wallet without an enclave yet, we'll generate an enclave\n            const result = await generateWallet({\n                authToken: authToken.storedToken.cookieString,\n                client: this.client,\n                ecosystem: this.ecosystem,\n            });\n            return this.postLogin({\n                storedToken: authToken.storedToken,\n                walletDetails: {\n                    walletAddress: result.address,\n                },\n            });\n        }\n        // If this is an existing sharded wallet or in-app wallet, we'll login with the sharded wallet\n        const result = await this.AuthQuerier.call({\n            params: {\n                recoveryCode,\n                storedToken: authToken.storedToken,\n            },\n            procedureName: \"loginWithStoredTokenDetails\",\n        });\n        return this.postLogin(result);\n    }\n    /**\n     * Used to log the user into their thirdweb wallet on your platform via a myriad of auth providers\n     * @example\n     * ```typescript\n     * const thirdwebInAppWallet = new InAppWalletSdk({clientId: \"YOUR_CLIENT_ID\", chain: \"Polygon\"})\n     * try {\n     *   const user = await thirdwebInAppWallet.auth.loginWithModal();\n     *   // user is now logged in\n     * } catch (e) {\n     *   // User closed modal or something else went wrong during the authentication process\n     *   console.error(e)\n     * }\n     * ```\n     * @returns `{{user: InitializedUser}}` An InitializedUser object.\n     */\n    async loginWithModal() {\n        return this.BaseLogin.loginWithModal();\n    }\n    async authenticateWithModal() {\n        return this.BaseLogin.authenticateWithModal();\n    }\n    /**\n     * Used to log the user into their thirdweb wallet using email OTP\n     * @example\n     * ```typescript\n     *  // Basic Flow\n     *  const thirdwebInAppWallet = new InAppWalletSdk({clientId: \"\", chain: \"Polygon\"});\n     *  try {\n     *    // prompts user to enter the code they received\n     *    const user = await thirdwebInAppWallet.auth.loginWithThirdwebEmailOtp({ email : \"you@example.com\" });\n     *    // user is now logged in\n     *  } catch (e) {\n     *    // User closed the OTP modal or something else went wrong during the authentication process\n     *    console.error(e)\n     *  }\n     * ```\n     * @param args - args.email: We will send the email an OTP that needs to be entered in order for them to be logged in.\n     * @returns `{{user: InitializedUser}}` An InitializedUser object. See {@link InAppWalletSdk.getUser} for more\n     */\n    async loginWithIframe(args) {\n        return this.BaseLogin.loginWithIframe(args);\n    }\n    async authenticateWithIframe(args) {\n        return this.BaseLogin.authenticateWithIframe(args);\n    }\n    /**\n     * @internal\n     */\n    async loginWithCustomJwt(args) {\n        return this.BaseLogin.loginWithCustomJwt(args);\n    }\n    async authenticateWithCustomJwt(args) {\n        return this.BaseLogin.authenticateWithCustomJwt(args);\n    }\n    /**\n     * @internal\n     */\n    async loginWithCustomAuthEndpoint(args) {\n        return this.BaseLogin.loginWithCustomAuthEndpoint(args);\n    }\n    async authenticateWithCustomAuthEndpoint(args) {\n        return this.BaseLogin.authenticateWithCustomAuthEndpoint(args);\n    }\n    /**\n     * A headless way to send the users at the passed email an OTP code.\n     * You need to then call {@link Auth.loginWithEmailOtp} in order to complete the login process\n     * @example\n     * @param param0.email\n     * ```typescript\n     *  const thirdwebInAppWallet = new InAppWalletSdk({clientId: \"\", chain: \"Polygon\"});\n     *  // sends user an OTP code\n     * try {\n     *    await thirdwebInAppWallet.auth.sendEmailLoginOtp({ email : \"you@example.com\" });\n     * } catch(e) {\n     *    // Error Sending user's email an OTP code\n     *    console.error(e);\n     * }\n     *\n     * // Then when your user is ready to verify their OTP\n     * try {\n     *    const user = await thirdwebInAppWallet.auth.verifyEmailLoginOtp({ email: \"you@example.com\", otp: \"6-DIGIT_CODE_HERE\" });\n     * } catch(e) {\n     *    // Error verifying the OTP code\n     *    console.error(e)\n     * }\n     * ```\n     * @param param0 - param0.email We will send the email an OTP that needs to be entered in order for them to be logged in.\n     * @returns `{{ isNewUser: boolean }}` IsNewUser indicates if the user is a new user to your platform\n     * @internal\n     */\n    async sendEmailLoginOtp({ email, }) {\n        return this.BaseLogin.sendEmailLoginOtp({\n            email,\n        });\n    }\n    /**\n     * @internal\n     */\n    async sendSmsLoginOtp({ phoneNumber, }) {\n        return this.BaseLogin.sendSmsLoginOtp({\n            phoneNumber,\n        });\n    }\n    /**\n     * Used to verify the otp that the user receives from thirdweb\n     *\n     * See {@link Auth.sendEmailLoginOtp} for how the headless call flow looks like. Simply swap out the calls to `loginWithThirdwebEmailOtp` with `verifyThirdwebEmailLoginOtp`\n     * @param args - props.email We will send the email an OTP that needs to be entered in order for them to be logged in.\n     * props.otp The code that the user received in their email\n     * @returns `{{user: InitializedUser}}` An InitializedUser object containing the user's status, wallet, authDetails, and more\n     * @internal\n     */\n    async loginWithEmailOtp(args) {\n        await this.preLogin();\n        return this.BaseLogin.loginWithEmailOtp(args);\n    }\n    async authenticateWithEmailOtp(args) {\n        return this.BaseLogin.authenticateWithEmailOtp(args);\n    }\n    /**\n     * @internal\n     */\n    async loginWithSmsOtp(args) {\n        await this.preLogin();\n        return this.BaseLogin.loginWithSmsOtp(args);\n    }\n    async authenticateWithSmsOtp(args) {\n        return this.BaseLogin.authenticateWithSmsOtp(args);\n    }\n    /**\n     * Logs any existing user out of their wallet.\n     * @returns `{{success: boolean}}` true if a user is successfully logged out. false if there's no user currently logged in.\n     * @internal\n     */\n    async logout() {\n        const isRemoveAuthCookie = await this.localStorage.removeAuthCookie();\n        const isRemoveUserId = await this.localStorage.removeWalletUserId();\n        return {\n            success: isRemoveAuthCookie || isRemoveUserId,\n        };\n    }\n}\n//# sourceMappingURL=iframe-auth.js.map","import { stringify } from \"../../../../../utils/json.js\";\nimport { getLoginCallbackUrl, getLoginUrl, } from \"../../../core/authentication/getLoginPath.js\";\n/**\n * @internal\n */\nexport const sendOtp = async (args) => {\n    const { client, ecosystem } = args;\n    const url = getLoginUrl({ authOption: args.strategy, client, ecosystem });\n    const headers = {\n        \"Content-Type\": \"application/json\",\n        \"x-client-id\": client.clientId,\n    };\n    if (ecosystem?.id) {\n        headers[\"x-ecosystem-id\"] = ecosystem.id;\n    }\n    if (ecosystem?.partnerId) {\n        headers[\"x-ecosystem-partner-id\"] = ecosystem.partnerId;\n    }\n    const body = (() => {\n        switch (args.strategy) {\n            case \"email\":\n                return {\n                    email: args.email,\n                };\n            case \"phone\":\n                return {\n                    phone: args.phoneNumber,\n                };\n        }\n    })();\n    const response = await fetch(url, {\n        body: stringify(body),\n        headers,\n        method: \"POST\",\n    });\n    if (!response.ok) {\n        throw new Error(\"Failed to send verification code\");\n    }\n    return await response.json();\n};\n/**\n * @internal\n */\nexport const verifyOtp = async (args) => {\n    const { client, ecosystem } = args;\n    const url = getLoginCallbackUrl({\n        authOption: args.strategy,\n        client: args.client,\n        ecosystem: args.ecosystem,\n    });\n    const headers = {\n        \"Content-Type\": \"application/json\",\n        \"x-client-id\": client.clientId,\n    };\n    if (ecosystem?.id) {\n        headers[\"x-ecosystem-id\"] = ecosystem.id;\n    }\n    if (ecosystem?.partnerId) {\n        headers[\"x-ecosystem-partner-id\"] = ecosystem.partnerId;\n    }\n    const body = (() => {\n        switch (args.strategy) {\n            case \"email\":\n                return {\n                    code: args.verificationCode,\n                    email: args.email,\n                };\n            case \"phone\":\n                return {\n                    code: args.verificationCode,\n                    phone: args.phoneNumber,\n                };\n        }\n    })();\n    const response = await fetch(url, {\n        body: stringify(body),\n        headers,\n        method: \"POST\",\n    });\n    if (!response.ok) {\n        throw new Error(\"Failed to verify verification code\");\n    }\n    return await response.json();\n};\n//# sourceMappingURL=otp.js.map","import { trackTransaction } from \"../../../../analytics/track/transaction.js\";\nimport { getCachedChain } from \"../../../../chains/utils.js\";\nimport { eth_sendRawTransaction } from \"../../../../rpc/actions/eth_sendRawTransaction.js\";\nimport { getRpcClient } from \"../../../../rpc/rpc.js\";\nimport { getAddress } from \"../../../../utils/address.js\";\nimport { getThirdwebDomains } from \"../../../../utils/domains.js\";\nimport { hexToString } from \"../../../../utils/encoding/hex.js\";\nimport { parseTypedData } from \"../../../../utils/signatures/helpers/parse-typed-data.js\";\n/**\n *\n */\nexport class IFrameWallet {\n    /**\n     * Not meant to be initialized directly. Call {@link initializeUser} to get an instance\n     * @internal\n     */\n    constructor({ client, ecosystem, querier, localStorage, }) {\n        Object.defineProperty(this, \"client\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"ecosystem\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"walletManagerQuerier\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"localStorage\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.client = client;\n        this.ecosystem = ecosystem;\n        this.walletManagerQuerier = querier;\n        this.localStorage = localStorage;\n    }\n    /**\n     * Used to set-up the user device in the case that they are using incognito\n     * @returns `{walletAddress : string }` The user's wallet details\n     * @internal\n     */\n    async postWalletSetUp(authResult) {\n        if (authResult.deviceShareStored) {\n            await this.localStorage.saveDeviceShare(authResult.deviceShareStored, authResult.storedToken.authDetails.userWalletId);\n        }\n    }\n    /**\n     * Gets the various status states of the user\n     * @example\n     * ```typescript\n     *  const userStatus = await Paper.getUserWalletStatus();\n     *  switch (userStatus.status) {\n     *  case UserWalletStatus.LOGGED_OUT: {\n     *    // User is logged out, call one of the auth methods on Paper.auth to authenticate the user\n     *    break;\n     *  }\n     *  case UserWalletStatus.LOGGED_IN_WALLET_UNINITIALIZED: {\n     *    // User is logged in, but does not have a wallet associated with it\n     *    // you also have access to the user's details\n     *    userStatus.user.authDetails;\n     *    break;\n     *  }\n     *  case UserWalletStatus.LOGGED_IN_NEW_DEVICE: {\n     *    // User is logged in and created a wallet already, but is missing the device shard\n     *    // You have access to:\n     *    userStatus.user.authDetails;\n     *    userStatus.user.walletAddress;\n     *    break;\n     *  }\n     *  case UserWalletStatus.LOGGED_IN_WALLET_INITIALIZED: {\n     *    // user is logged in and wallet is all set up.\n     *    // You have access to:\n     *    userStatus.user.authDetails;\n     *    userStatus.user.walletAddress;\n     *    userStatus.user.wallet;\n     *    break;\n     *  }\n     *}\n     *```\n     * @returns `{GetUserWalletStatusFnReturnType}` an object to containing various information on the user statuses\n     * @internal\n     */\n    async getUserWalletStatus() {\n        const userStatus = await this.walletManagerQuerier.call({\n            params: undefined,\n            procedureName: \"getUserStatus\",\n        });\n        if (userStatus.status === \"Logged In, Wallet Initialized\") {\n            return {\n                status: \"Logged In, Wallet Initialized\",\n                ...userStatus.user,\n                account: await this.getAccount(),\n            };\n        }\n        if (userStatus.status === \"Logged In, New Device\") {\n            return {\n                status: \"Logged In, New Device\",\n                ...userStatus.user,\n            };\n        }\n        if (userStatus.status === \"Logged In, Wallet Uninitialized\") {\n            return {\n                status: \"Logged In, Wallet Uninitialized\",\n                ...userStatus.user,\n            };\n        }\n        // Logged out\n        return { status: userStatus.status };\n    }\n    /**\n     * Returns an account that communicates with the iFrame for signing operations\n     * @internal\n     */\n    async getAccount() {\n        const querier = this\n            .walletManagerQuerier;\n        const client = this.client;\n        const partnerId = this.ecosystem?.partnerId;\n        const { address } = await querier.call({\n            params: undefined,\n            procedureName: \"getAddress\",\n        });\n        const _signTransaction = async (tx) => {\n            // biome-ignore lint/suspicious/noExplicitAny: ethers tx transformation\n            const transaction = {\n                chainId: tx.chainId,\n                data: tx.data,\n                gasLimit: tx.gas,\n                nonce: tx.nonce,\n                to: tx.to ?? undefined,\n                value: tx.value,\n            };\n            if (tx.maxFeePerGas) {\n                // ethers (in the iframe) rejects any type 0 transaction with unknown keys\n                // TODO remove this once iframe is upgraded to v5\n                transaction.accessList = tx.accessList;\n                transaction.maxFeePerGas = tx.maxFeePerGas;\n                transaction.maxPriorityFeePerGas = tx.maxPriorityFeePerGas;\n                transaction.type = 2;\n            }\n            else {\n                transaction.gasPrice = tx.gasPrice;\n                transaction.type = 0;\n            }\n            const RPC_URL = getThirdwebDomains().rpc;\n            const { signedTransaction } = await querier.call({\n                params: {\n                    chainId: tx.chainId,\n                    partnerId,\n                    rpcEndpoint: `https://${tx.chainId}.${RPC_URL}`,\n                    transaction, // TODO (ew) shouldnt be needed\n                },\n                procedureName: \"signTransaction\",\n            });\n            return signedTransaction;\n        };\n        return {\n            address: getAddress(address),\n            async sendTransaction(tx) {\n                const rpcRequest = getRpcClient({\n                    chain: getCachedChain(tx.chainId),\n                    client,\n                });\n                const signedTx = await _signTransaction(tx);\n                const transactionHash = await eth_sendRawTransaction(rpcRequest, signedTx);\n                trackTransaction({\n                    chainId: tx.chainId,\n                    client,\n                    contractAddress: tx.to ?? undefined,\n                    gasPrice: tx.gasPrice,\n                    transactionHash,\n                    walletAddress: address,\n                    walletType: \"inApp\",\n                });\n                return { transactionHash };\n            },\n            async signMessage({ message }) {\n                // in-app wallets use ethers to sign messages, which always expects a string (or bytes maybe but string is safest)\n                const messageDecoded = (() => {\n                    if (typeof message === \"string\") {\n                        return message;\n                    }\n                    if (message.raw instanceof Uint8Array) {\n                        return message.raw;\n                    }\n                    return hexToString(message.raw);\n                })();\n                const { signedMessage } = await querier.call({\n                    params: {\n                        chainId: 1, // needs bytes or string\n                        // biome-ignore lint/suspicious/noExplicitAny: ethers tx transformation\n                        message: messageDecoded,\n                        partnerId, // TODO check if we need this\n                    },\n                    procedureName: \"signMessage\",\n                });\n                return signedMessage;\n            },\n            async signTransaction(tx) {\n                if (!tx.chainId) {\n                    throw new Error(\"chainId required in tx to sign\");\n                }\n                return _signTransaction({\n                    ...tx,\n                    chainId: tx.chainId,\n                });\n            },\n            async signTypedData(_typedData) {\n                const parsedTypedData = parseTypedData(_typedData);\n                // deleting EIP712 Domain as it results in ambiguous primary type on some cases\n                // this happens when going from viem to ethers via the iframe\n                if (parsedTypedData.types?.EIP712Domain) {\n                    parsedTypedData.types.EIP712Domain = undefined;\n                }\n                const domain = parsedTypedData.domain;\n                const chainId = domain?.chainId;\n                const verifyingContract = domain?.verifyingContract\n                    ? { verifyingContract: domain?.verifyingContract }\n                    : {};\n                const domainData = {\n                    ...verifyingContract,\n                    name: domain?.name,\n                    version: domain?.version,\n                };\n                // chain id can't be included if it wasn't explicitly specified\n                if (chainId) {\n                    domainData.chainId = chainId;\n                }\n                const RPC_URL = getThirdwebDomains().rpc;\n                const { signedTypedData } = await querier.call({\n                    params: {\n                        chainId: Number.parseInt(BigInt(chainId || 1).toString()),\n                        domain: domainData,\n                        message: parsedTypedData.message,\n                        partnerId,\n                        rpcEndpoint: `https://${chainId}.${RPC_URL}`,\n                        types: parsedTypedData.types, // TODO (ew) shouldnt be needed\n                    },\n                    procedureName: \"signTypedDataV4\",\n                });\n                return signedTypedData;\n            },\n        };\n    }\n}\n//# sourceMappingURL=iframe-wallet.js.map","import { getThirdwebBaseUrl } from \"../../../../utils/domains.js\";\nimport { inMemoryStorage } from \"../../../../utils/storage/inMemoryStorage.js\";\nimport { webLocalStorage } from \"../../../../utils/storage/webStorage.js\";\nimport { getUserStatus } from \"../../core/actions/get-enclave-user-status.js\";\nimport { authEndpoint } from \"../../core/authentication/authEndpoint.js\";\nimport { backendAuthenticate } from \"../../core/authentication/backend.js\";\nimport { ClientScopedStorage } from \"../../core/authentication/client-scoped-storage.js\";\nimport { guestAuthenticate } from \"../../core/authentication/guest.js\";\nimport { customJwt } from \"../../core/authentication/jwt.js\";\nimport { getLinkedProfilesInternal, linkAccount, unlinkAccount, } from \"../../core/authentication/linkAccount.js\";\nimport { loginWithPasskey, registerPasskey, } from \"../../core/authentication/passkeys.js\";\nimport { siweAuthenticate } from \"../../core/authentication/siwe.js\";\nimport { EnclaveWallet } from \"../../core/wallet/enclave-wallet.js\";\nimport { InAppWalletIframeCommunicator } from \"../utils/iFrameCommunication/InAppWalletIframeCommunicator.js\";\nimport { Auth } from \"./auth/iframe-auth.js\";\nimport { loginWithOauth, loginWithOauthRedirect } from \"./auth/oauth.js\";\nimport { sendOtp, verifyOtp } from \"./auth/otp.js\";\nimport { IFrameWallet } from \"./iframe-wallet.js\";\n/**\n * @internal\n */\nexport class InAppWebConnector {\n    isClientIdLegacyPaper(clientId) {\n        if (clientId.indexOf(\"-\") > 0 && clientId.length === 36) {\n            return true;\n        }\n        return false;\n    }\n    /**\n     * @example\n     * `const thirdwebInAppWallet = new InAppWalletSdk({ clientId: \"\", chain: \"Goerli\" });`\n     * @internal\n     */\n    constructor({ client, onAuthSuccess, ecosystem, passkeyDomain, storage, }) {\n        Object.defineProperty(this, \"client\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"ecosystem\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"querier\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"storage\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"wallet\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * Used to manage the Auth state of the user.\n         */\n        Object.defineProperty(this, \"auth\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"passkeyDomain\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        if (this.isClientIdLegacyPaper(client.clientId)) {\n            throw new Error(\"You are using a legacy clientId. Please use the clientId found on the thirdweb dashboard settings page\");\n        }\n        const baseUrl = getThirdwebBaseUrl(\"inAppWallet\");\n        this.client = client;\n        this.ecosystem = ecosystem;\n        this.passkeyDomain = passkeyDomain;\n        this.storage = new ClientScopedStorage({\n            clientId: client.clientId,\n            ecosystem: ecosystem,\n            storage: storage ?? getDefaultStorage(),\n        });\n        this.querier = new InAppWalletIframeCommunicator({\n            baseUrl,\n            clientId: client.clientId,\n            ecosystem,\n        });\n        this.auth = new Auth({\n            baseUrl,\n            client,\n            ecosystem,\n            localStorage: this.storage,\n            onAuthSuccess: async (authResult) => {\n                onAuthSuccess?.(authResult);\n                if (authResult.storedToken.authDetails.walletType === \"sharded\") {\n                    // If this is an existing sharded ecosystem wallet, we'll need to migrate\n                    const result = await this.querier.call({\n                        params: {\n                            storedToken: authResult.storedToken,\n                        },\n                        procedureName: \"migrateFromShardToEnclave\",\n                    });\n                    if (!result) {\n                        console.warn(\"Failed to migrate from sharded to enclave wallet, continuing with sharded wallet\");\n                    }\n                }\n                this.wallet = await this.initializeWallet(authResult.storedToken.cookieString);\n                if (!this.wallet) {\n                    throw new Error(\"Failed to initialize wallet\");\n                }\n                const deviceShareStored = \"deviceShareStored\" in authResult.walletDetails\n                    ? authResult.walletDetails.deviceShareStored\n                    : undefined;\n                await this.wallet.postWalletSetUp({\n                    deviceShareStored,\n                    storedToken: authResult.storedToken,\n                });\n                if (this.wallet instanceof IFrameWallet) {\n                    await this.querier.call({\n                        params: {\n                            authCookie: authResult.storedToken.cookieString,\n                            clientId: this.client.clientId,\n                            // For enclave wallets we won't have a device share\n                            deviceShareStored: \"deviceShareStored\" in authResult.walletDetails\n                                ? authResult.walletDetails.deviceShareStored\n                                : null,\n                            ecosystemId: ecosystem?.id,\n                            partnerId: ecosystem?.partnerId,\n                            walletUserId: authResult.storedToken.authDetails.userWalletId,\n                        },\n                        procedureName: \"initIframe\",\n                    });\n                }\n                return {\n                    user: {\n                        account: await this.wallet.getAccount(),\n                        authDetails: authResult.storedToken.authDetails,\n                        status: \"Logged In, Wallet Initialized\",\n                        walletAddress: authResult.walletDetails.walletAddress,\n                    },\n                };\n            },\n            querier: this.querier,\n        });\n    }\n    async initializeWallet(authToken) {\n        const storedAuthToken = await this.storage.getAuthCookie();\n        if (!authToken && storedAuthToken === null) {\n            throw new Error(\"No auth token provided and no stored auth token found to initialize the wallet\");\n        }\n        const user = await getUserStatus({\n            authToken: authToken || storedAuthToken,\n            client: this.client,\n            ecosystem: this.ecosystem,\n        });\n        if (!user) {\n            throw new Error(\"Cannot initialize wallet, no user logged in\");\n        }\n        if (user.wallets.length === 0) {\n            throw new Error(\"Cannot initialize wallet, this user does not have a wallet generated yet\");\n        }\n        if (user.wallets[0]?.type === \"enclave\") {\n            return new EnclaveWallet({\n                address: user.wallets[0].address,\n                client: this.client,\n                ecosystem: this.ecosystem,\n                storage: this.storage,\n            });\n        }\n        return new IFrameWallet({\n            client: this.client,\n            ecosystem: this.ecosystem,\n            localStorage: this.storage,\n            querier: this.querier,\n        });\n    }\n    /**\n     * Gets the user if they're logged in\n     * @example\n     * ```js\n     *  const user = await thirdwebInAppWallet.getUser();\n     *  switch (user.status) {\n     *     case UserWalletStatus.LOGGED_OUT: {\n     *       // User is logged out, call one of the auth methods on thirdwebInAppWallet.auth to authenticate the user\n     *       break;\n     *     }\n     *     case UserWalletStatus.LOGGED_IN_WALLET_INITIALIZED: {\n     *       // user is logged in and wallet is all set up.\n     *       // You have access to:\n     *       user.status;\n     *       user.authDetails;\n     *       user.walletAddress;\n     *       user.wallet;\n     *       break;\n     *     }\n     * }\n     * ```\n     * @returns GetUser - an object to containing various information on the user statuses\n     */\n    async getUser() {\n        // If we don't have a wallet yet we'll create one\n        if (!this.wallet) {\n            const localAuthToken = await this.storage.getAuthCookie();\n            if (!localAuthToken) {\n                return { status: \"Logged Out\" };\n            }\n            this.wallet = await this.initializeWallet(localAuthToken);\n        }\n        if (!this.wallet) {\n            throw new Error(\"Wallet not initialized\");\n        }\n        return await this.wallet.getUserWalletStatus();\n    }\n    getAccount() {\n        if (!this.wallet) {\n            throw new Error(\"Wallet not initialized\");\n        }\n        return this.wallet.getAccount();\n    }\n    async preAuthenticate(args) {\n        return sendOtp({\n            ...args,\n            client: this.client,\n            ecosystem: this.ecosystem,\n        });\n    }\n    async authenticateWithRedirect(strategy, mode, redirectUrl) {\n        return loginWithOauthRedirect({\n            authOption: strategy,\n            client: this.client,\n            ecosystem: this.ecosystem,\n            mode,\n            redirectUrl,\n        });\n    }\n    async loginWithAuthToken(authResult, recoveryCode) {\n        return this.auth.loginWithAuthToken(authResult, recoveryCode);\n    }\n    /**\n     * Authenticates the user and returns the auth token, but does not instantiate their wallet\n     */\n    async authenticate(args) {\n        const strategy = args.strategy;\n        switch (strategy) {\n            case \"email\":\n                return verifyOtp({\n                    ...args,\n                    client: this.client,\n                    ecosystem: this.ecosystem,\n                });\n            case \"phone\":\n                return verifyOtp({\n                    ...args,\n                    client: this.client,\n                    ecosystem: this.ecosystem,\n                });\n            case \"auth_endpoint\": {\n                return authEndpoint({\n                    client: this.client,\n                    ecosystem: this.ecosystem,\n                    payload: args.payload,\n                });\n            }\n            case \"jwt\":\n                return customJwt({\n                    client: this.client,\n                    ecosystem: this.ecosystem,\n                    jwt: args.jwt,\n                });\n            case \"passkey\": {\n                return this.passkeyAuth(args);\n            }\n            case \"iframe_email_verification\": {\n                return this.auth.authenticateWithIframe({\n                    email: args.email,\n                });\n            }\n            case \"iframe\": {\n                return this.auth.authenticateWithModal();\n            }\n            case \"apple\":\n            case \"facebook\":\n            case \"google\":\n            case \"telegram\":\n            case \"github\":\n            case \"twitch\":\n            case \"farcaster\":\n            case \"line\":\n            case \"x\":\n            case \"tiktok\":\n            case \"epic\":\n            case \"steam\":\n            case \"coinbase\":\n            case \"discord\": {\n                return loginWithOauth({\n                    authOption: strategy,\n                    client: this.client,\n                    closeOpenedWindow: args.closeOpenedWindow,\n                    ecosystem: this.ecosystem,\n                    openedWindow: args.openedWindow,\n                });\n            }\n            case \"guest\": {\n                return guestAuthenticate({\n                    client: this.client,\n                    ecosystem: this.ecosystem,\n                    storage: this.storage,\n                });\n            }\n            case \"backend\": {\n                return backendAuthenticate({\n                    client: this.client,\n                    ecosystem: this.ecosystem,\n                    walletSecret: args.walletSecret,\n                });\n            }\n            case \"wallet\": {\n                return siweAuthenticate({\n                    client: this.client,\n                    ecosystem: this.ecosystem,\n                    wallet: args.wallet,\n                    chain: args.chain,\n                });\n            }\n        }\n    }\n    /**\n     * Authenticates the user then instantiates their wallet using the resulting auth token\n     */\n    async connect(args) {\n        const strategy = args.strategy;\n        switch (strategy) {\n            case \"auth_endpoint\":\n            case \"jwt\": {\n                const authToken = await this.authenticate(args);\n                return await this.loginWithAuthToken(authToken, args.encryptionKey);\n            }\n            case \"iframe_email_verification\": {\n                return this.auth.loginWithIframe({\n                    email: args.email,\n                });\n            }\n            case \"iframe\": {\n                return this.auth.loginWithModal();\n            }\n            case \"passkey\": {\n                const authToken = await this.passkeyAuth(args);\n                return this.loginWithAuthToken(authToken);\n            }\n            case \"backend\":\n            case \"phone\":\n            case \"email\":\n            case \"wallet\":\n            case \"apple\":\n            case \"facebook\":\n            case \"google\":\n            case \"farcaster\":\n            case \"telegram\":\n            case \"github\":\n            case \"line\":\n            case \"x\":\n            case \"tiktok\":\n            case \"epic\":\n            case \"guest\":\n            case \"coinbase\":\n            case \"twitch\":\n            case \"steam\":\n            case \"discord\": {\n                const authToken = await this.authenticate(args);\n                return await this.auth.loginWithAuthToken(authToken);\n            }\n            default:\n                assertUnreachable(strategy);\n        }\n    }\n    async logout() {\n        return await this.auth.logout();\n    }\n    async passkeyAuth(args) {\n        const { PasskeyWebClient } = await import(\"./auth/passkeys.js\");\n        const { passkeyName, storeLastUsedPasskey = true } = args;\n        const passkeyClient = new PasskeyWebClient();\n        const storage = this.storage;\n        if (args.type === \"sign-up\") {\n            return registerPasskey({\n                client: this.client,\n                ecosystem: this.ecosystem,\n                passkeyClient,\n                rp: {\n                    id: this.passkeyDomain ?? window.location.hostname,\n                    name: this.passkeyDomain ?? window.document.title,\n                },\n                storage: storeLastUsedPasskey ? storage : undefined,\n                username: passkeyName,\n            });\n        }\n        return loginWithPasskey({\n            client: this.client,\n            ecosystem: this.ecosystem,\n            passkeyClient,\n            rp: {\n                id: this.passkeyDomain ?? window.location.hostname,\n                name: this.passkeyDomain ?? window.document.title,\n            },\n            storage: storeLastUsedPasskey ? storage : undefined,\n        });\n    }\n    async linkProfile(args) {\n        const { storedToken } = await this.authenticate(args);\n        return await linkAccount({\n            client: args.client,\n            ecosystem: args.ecosystem || this.ecosystem,\n            storage: this.storage,\n            tokenToLink: storedToken.cookieString,\n        });\n    }\n    async unlinkProfile(profile, allowAccountDeletion) {\n        return await unlinkAccount({\n            allowAccountDeletion,\n            client: this.client,\n            ecosystem: this.ecosystem,\n            profileToUnlink: profile,\n            storage: this.storage,\n        });\n    }\n    async getProfiles() {\n        return getLinkedProfilesInternal({\n            client: this.client,\n            ecosystem: this.ecosystem,\n            storage: this.storage,\n        });\n    }\n}\nfunction assertUnreachable(x, message) {\n    throw new Error(message ?? `Invalid param: ${x}`);\n}\nfunction getDefaultStorage() {\n    if (typeof window !== \"undefined\" && window.localStorage) {\n        return webLocalStorage;\n    }\n    // default to in-memory storage if we're not in the browser\n    return inMemoryStorage;\n}\n//# sourceMappingURL=web-connector.js.map"],"file":"assets/web-connector-DYNuAmEW.js"}