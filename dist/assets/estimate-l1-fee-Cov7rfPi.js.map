{"version":3,"file":"estimate-l1-fee-Cov7rfPi.js","sources":["../../node_modules/ox/_esm/core/AccessList.js","../../node_modules/ox/_esm/core/Value.js","../../node_modules/ox/_esm/core/TransactionEnvelope.js","../../node_modules/ox/_esm/core/TransactionEnvelopeLegacy.js","../../node_modules/ox/_esm/core/TransactionEnvelopeEip1559.js","../../node_modules/ox/_esm/core/TransactionEnvelopeEip2930.js","../../node_modules/ox/_esm/core/TransactionEnvelopeEip7702.js","../../node_modules/thirdweb/dist/esm/transaction/serialize-transaction.js","../../node_modules/thirdweb/dist/esm/gas/estimate-l1-fee.js"],"sourcesContent":["import * as Address from './Address.js';\nimport * as Errors from './Errors.js';\nimport * as Hash from './Hash.js';\nimport * as Hex from './Hex.js';\n/**\n * Converts a list of Access List tuples into a object-formatted list.\n *\n * @example\n * ```ts twoslash\n * import { AccessList } from 'ox'\n *\n * const accessList = AccessList.fromTupleList([\n *   [\n *     '0x0000000000000000000000000000000000000000',\n *     [\n *       '0x0000000000000000000000000000000000000000000000000000000000000001',\n *       '0x60fdd29ff912ce880cd3edaf9f932dc61d3dae823ea77e0323f94adb9f6a72fe',\n *     ],\n *   ],\n * ])\n * // @log: [\n * // @log:   {\n * // @log:     address: '0x0000000000000000000000000000000000000000',\n * // @log:     storageKeys: [\n * // @log:       '0x0000000000000000000000000000000000000000000000000000000000000001',\n * // @log:       '0x60fdd29ff912ce880cd3edaf9f932dc61d3dae823ea77e0323f94adb9f6a72fe',\n * // @log:     ],\n * // @log:   },\n * // @log: ]\n * ```\n *\n * @param accessList - List of tuples.\n * @returns Access list.\n */\nexport function fromTupleList(accessList) {\n    const list = [];\n    for (let i = 0; i < accessList.length; i++) {\n        const [address, storageKeys] = accessList[i];\n        if (address)\n            Address.assert(address, { strict: false });\n        list.push({\n            address: address,\n            storageKeys: storageKeys.map((key) => Hash.validate(key) ? key : Hex.trimLeft(key)),\n        });\n    }\n    return list;\n}\n/**\n * Converts a structured Access List into a list of tuples.\n *\n * @example\n * ```ts twoslash\n * import { AccessList } from 'ox'\n *\n * const accessList = AccessList.toTupleList([\n *   {\n *     address: '0x0000000000000000000000000000000000000000',\n *     storageKeys: [\n *       '0x0000000000000000000000000000000000000000000000000000000000000001',\n *       '0x60fdd29ff912ce880cd3edaf9f932dc61d3dae823ea77e0323f94adb9f6a72fe'],\n *   },\n * ])\n * // @log: [\n * // @log:   [\n * // @log:     '0x0000000000000000000000000000000000000000',\n * // @log:     [\n * // @log:       '0x0000000000000000000000000000000000000000000000000000000000000001',\n * // @log:       '0x60fdd29ff912ce880cd3edaf9f932dc61d3dae823ea77e0323f94adb9f6a72fe',\n * // @log:     ],\n * // @log:   ],\n * // @log: ]\n * ```\n *\n * @param accessList - Access list.\n * @returns List of tuples.\n */\nexport function toTupleList(accessList) {\n    if (!accessList || accessList.length === 0)\n        return [];\n    const tuple = [];\n    for (const { address, storageKeys } of accessList) {\n        for (let j = 0; j < storageKeys.length; j++)\n            if (Hex.size(storageKeys[j]) !== 32)\n                throw new InvalidStorageKeySizeError({\n                    storageKey: storageKeys[j],\n                });\n        if (address)\n            Address.assert(address, { strict: false });\n        tuple.push([address, storageKeys]);\n    }\n    return tuple;\n}\n/** Thrown when the size of a storage key is invalid. */\nexport class InvalidStorageKeySizeError extends Errors.BaseError {\n    constructor({ storageKey }) {\n        super(`Size for storage key \"${storageKey}\" is invalid. Expected 32 bytes. Got ${Hex.size(storageKey)} bytes.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AccessList.InvalidStorageKeySizeError'\n        });\n    }\n}\n//# sourceMappingURL=AccessList.js.map","import * as Errors from './Errors.js';\n/** @see https://ethereum.github.io/yellowpaper/paper.pdf */\nexport const exponents = {\n    wei: 0,\n    gwei: 9,\n    szabo: 12,\n    finney: 15,\n    ether: 18,\n};\n/**\n * Formats a `bigint` Value to its string representation (divided by the given exponent).\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n *\n * Value.format(420_000_000_000n, 9)\n * // @log: '420'\n * ```\n *\n * @param value - The `bigint` Value to format.\n * @param decimals - The exponent to divide the `bigint` Value by.\n * @returns The string representation of the Value.\n */\nexport function format(value, decimals = 0) {\n    let display = value.toString();\n    const negative = display.startsWith('-');\n    if (negative)\n        display = display.slice(1);\n    display = display.padStart(decimals, '0');\n    let [integer, fraction] = [\n        display.slice(0, display.length - decimals),\n        display.slice(display.length - decimals),\n    ];\n    fraction = fraction.replace(/(0+)$/, '');\n    return `${negative ? '-' : ''}${integer || '0'}${fraction ? `.${fraction}` : ''}`;\n}\n/**\n * Formats a `bigint` Value (default: wei) to a string representation of Ether.\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n *\n * Value.formatEther(1_000_000_000_000_000_000n)\n * // @log: '1'\n * ```\n *\n * @param wei - The Value to format.\n * @param unit - The unit to format the Value in. @default 'wei'.\n * @returns The Ether string representation of the Value.\n */\nexport function formatEther(wei, unit = 'wei') {\n    return format(wei, exponents.ether - exponents[unit]);\n}\n/**\n * Formats a `bigint` Value (default: wei) to a string representation of Gwei.\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n *\n * Value.formatGwei(1_000_000_000n)\n * // @log: '1'\n * ```\n *\n * @param wei - The Value to format.\n * @param unit - The unit to format the Value in. @default 'wei'.\n * @returns The Gwei string representation of the Value.\n */\nexport function formatGwei(wei, unit = 'wei') {\n    return format(wei, exponents.gwei - exponents[unit]);\n}\n/**\n * Parses a `string` representation of a Value to `bigint` (multiplied by the given exponent).\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n *\n * Value.from('420', 9)\n * // @log: 420000000000n\n * ```\n *\n * @param value - The string representation of the Value.\n * @param decimals - The exponent to multiply the Value by.\n * @returns The `bigint` representation of the Value.\n */\nexport function from(value, decimals = 0) {\n    if (!/^(-?)([0-9]*)\\.?([0-9]*)$/.test(value))\n        throw new InvalidDecimalNumberError({ value });\n    let [integer = '', fraction = '0'] = value.split('.');\n    const negative = integer.startsWith('-');\n    if (negative)\n        integer = integer.slice(1);\n    // trim trailing zeros.\n    fraction = fraction.replace(/(0+)$/, '');\n    // round off if the fraction is larger than the number of decimals.\n    if (decimals === 0) {\n        if (Math.round(Number(`.${fraction}`)) === 1)\n            integer = `${BigInt(integer) + 1n}`;\n        fraction = '';\n    }\n    else if (fraction.length > decimals) {\n        const [left, unit, right] = [\n            fraction.slice(0, decimals - 1),\n            fraction.slice(decimals - 1, decimals),\n            fraction.slice(decimals),\n        ];\n        const rounded = Math.round(Number(`${unit}.${right}`));\n        if (rounded > 9)\n            fraction = `${BigInt(left) + BigInt(1)}0`.padStart(left.length + 1, '0');\n        else\n            fraction = `${left}${rounded}`;\n        if (fraction.length > decimals) {\n            fraction = fraction.slice(1);\n            integer = `${BigInt(integer) + 1n}`;\n        }\n        fraction = fraction.slice(0, decimals);\n    }\n    else {\n        fraction = fraction.padEnd(decimals, '0');\n    }\n    return BigInt(`${negative ? '-' : ''}${integer}${fraction}`);\n}\n/**\n * Parses a string representation of Ether to a `bigint` Value (default: wei).\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n *\n * Value.fromEther('420')\n * // @log: 420000000000000000000n\n * ```\n *\n * @param ether - String representation of Ether.\n * @param unit - The unit to parse to. @default 'wei'.\n * @returns A `bigint` Value.\n */\nexport function fromEther(ether, unit = 'wei') {\n    return from(ether, exponents.ether - exponents[unit]);\n}\n/**\n * Parses a string representation of Gwei to a `bigint` Value (default: wei).\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n *\n * Value.fromGwei('420')\n * // @log: 420000000000n\n * ```\n *\n * @param gwei - String representation of Gwei.\n * @param unit - The unit to parse to. @default 'wei'.\n * @returns A `bigint` Value.\n */\nexport function fromGwei(gwei, unit = 'wei') {\n    return from(gwei, exponents.gwei - exponents[unit]);\n}\n/**\n * Thrown when a value is not a valid decimal number.\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n *\n * Value.fromEther('123.456.789')\n * // @error: Value.InvalidDecimalNumberError: Value `123.456.789` is not a valid decimal number.\n * ```\n */\nexport class InvalidDecimalNumberError extends Errors.BaseError {\n    constructor({ value }) {\n        super(`Value \\`${value}\\` is not a valid decimal number.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Value.InvalidDecimalNumberError'\n        });\n    }\n}\n//# sourceMappingURL=Value.js.map","import * as Errors from './Errors.js';\nimport * as Value from './Value.js';\n/**\n * Thrown when a fee cap is too high.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip1559 } from 'ox'\n *\n * TransactionEnvelopeEip1559.assert({\n *   maxFeePerGas: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n * })\n * // @error: TransactionEnvelope.FeeCapTooHighError: The fee cap (`maxFeePerGas`/`maxPriorityFeePerGas` = 115792089237316195423570985008687907853269984665640564039457584007913.129639936 gwei) cannot be higher than the maximum allowed value (2^256-1).\n * ```\n */\nexport class FeeCapTooHighError extends Errors.BaseError {\n    constructor({ feeCap, } = {}) {\n        super(`The fee cap (\\`maxFeePerGas\\`/\\`maxPriorityFeePerGas\\`${feeCap ? ` = ${Value.formatGwei(feeCap)} gwei` : ''}) cannot be higher than the maximum allowed value (2^256-1).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'TransactionEnvelope.FeeCapTooHighError'\n        });\n    }\n}\n/**\n * Thrown when a gas price is too high.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeLegacy } from 'ox'\n *\n * TransactionEnvelopeLegacy.assert({\n *   gasPrice: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n * })\n * // @error: TransactionEnvelope.GasPriceTooHighError: The gas price (`gasPrice` = 115792089237316195423570985008687907853269984665640564039457584007913.129639936 gwei) cannot be higher than the maximum allowed value (2^256-1).\n * ```\n */\nexport class GasPriceTooHighError extends Errors.BaseError {\n    constructor({ gasPrice, } = {}) {\n        super(`The gas price (\\`gasPrice\\`${gasPrice ? ` = ${Value.formatGwei(gasPrice)} gwei` : ''}) cannot be higher than the maximum allowed value (2^256-1).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'TransactionEnvelope.GasPriceTooHighError'\n        });\n    }\n}\n/**\n * Thrown when a chain ID is invalid.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip1559 } from 'ox'\n *\n * TransactionEnvelopeEip1559.assert({ chainId: 0 })\n * // @error: TransactionEnvelope.InvalidChainIdError: Chain ID \"0\" is invalid.\n * ```\n */\nexport class InvalidChainIdError extends Errors.BaseError {\n    constructor({ chainId }) {\n        super(typeof chainId !== 'undefined'\n            ? `Chain ID \"${chainId}\" is invalid.`\n            : 'Chain ID is invalid.');\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'TransactionEnvelope.InvalidChainIdError'\n        });\n    }\n}\n/**\n * Thrown when a serialized transaction is invalid.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip1559 } from 'ox'\n *\n * TransactionEnvelopeEip1559.deserialize('0x02c0')\n * // @error: TransactionEnvelope.InvalidSerializedError: Invalid serialized transaction of type \"eip1559\" was provided.\n * // @error: Serialized Transaction: \"0x02c0\"\n * // @error: Missing Attributes: chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gas, to, value, data, accessList\n * ```\n */\nexport class InvalidSerializedError extends Errors.BaseError {\n    constructor({ attributes, serialized, type, }) {\n        const missing = Object.entries(attributes)\n            .map(([key, value]) => (typeof value === 'undefined' ? key : undefined))\n            .filter(Boolean);\n        super(`Invalid serialized transaction of type \"${type}\" was provided.`, {\n            metaMessages: [\n                `Serialized Transaction: \"${serialized}\"`,\n                missing.length > 0 ? `Missing Attributes: ${missing.join(', ')}` : '',\n            ].filter(Boolean),\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'TransactionEnvelope.InvalidSerializedError'\n        });\n    }\n}\n/**\n * Thrown when a tip is higher than a fee cap.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip1559 } from 'ox'\n *\n * TransactionEnvelopeEip1559.assert({\n *   chainId: 1,\n *   maxFeePerGas: 10n,\n *   maxPriorityFeePerGas: 11n,\n * })\n * // @error: TransactionEnvelope.TipAboveFeeCapError: The provided tip (`maxPriorityFeePerGas` = 11 gwei) cannot be higher than the fee cap (`maxFeePerGas` = 10 gwei).\n * ```\n */\nexport class TipAboveFeeCapError extends Errors.BaseError {\n    constructor({ maxPriorityFeePerGas, maxFeePerGas, } = {}) {\n        super([\n            `The provided tip (\\`maxPriorityFeePerGas\\`${maxPriorityFeePerGas\n                ? ` = ${Value.formatGwei(maxPriorityFeePerGas)} gwei`\n                : ''}) cannot be higher than the fee cap (\\`maxFeePerGas\\`${maxFeePerGas ? ` = ${Value.formatGwei(maxFeePerGas)} gwei` : ''}).`,\n        ].join('\\n'));\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'TransactionEnvelope.TipAboveFeeCapError'\n        });\n    }\n}\n//# sourceMappingURL=TransactionEnvelope.js.map","import * as Address from './Address.js';\nimport * as Hash from './Hash.js';\nimport * as Hex from './Hex.js';\nimport * as Rlp from './Rlp.js';\nimport * as Signature from './Signature.js';\nimport * as TransactionEnvelope from './TransactionEnvelope.js';\nexport const type = 'legacy';\n/**\n * Asserts a {@link ox#TransactionEnvelopeLegacy.TransactionEnvelopeLegacy} is valid.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeLegacy, Value } from 'ox'\n *\n * TransactionEnvelopeLegacy.assert({\n *   gasPrice: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * // @error: GasPriceTooHighError:\n * // @error: The gas price (`gasPrice` = 115792089237316195423570985008687907853269984665640564039457584007913 gwei) cannot be\n * // @error: higher than the maximum allowed value (2^256-1).\n * ```\n *\n * @param envelope - The transaction envelope to assert.\n */\nexport function assert(envelope) {\n    const { chainId, gasPrice, to } = envelope;\n    if (to)\n        Address.assert(to, { strict: false });\n    if (typeof chainId !== 'undefined' && chainId <= 0)\n        throw new TransactionEnvelope.InvalidChainIdError({ chainId });\n    if (gasPrice && BigInt(gasPrice) > 2n ** 256n - 1n)\n        throw new TransactionEnvelope.GasPriceTooHighError({ gasPrice });\n}\n/**\n * Deserializes a {@link ox#TransactionEnvelopeLegacy.TransactionEnvelopeLegacy} from its serialized form.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeLegacy } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.deserialize('0x01ef0182031184773594008477359400809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c0')\n * // @log: {\n * // @log:   type: 'legacy',\n * // @log:   nonce: 785n,\n * // @log:   gasPrice: 2000000000n,\n * // @log:   gas: 1000000n,\n * // @log:   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n * // @log:   value: 1000000000000000000n,\n * // @log: }\n * ```\n *\n * @param serialized - The serialized transaction.\n * @returns Deserialized Transaction Envelope.\n */\nexport function deserialize(serialized) {\n    const tuple = Rlp.toHex(serialized);\n    const [nonce, gasPrice, gas, to, value, data, chainIdOrV_, r, s] = tuple;\n    if (!(tuple.length === 6 || tuple.length === 9))\n        throw new TransactionEnvelope.InvalidSerializedError({\n            attributes: {\n                nonce,\n                gasPrice,\n                gas,\n                to,\n                value,\n                data,\n                ...(tuple.length > 6\n                    ? {\n                        v: chainIdOrV_,\n                        r,\n                        s,\n                    }\n                    : {}),\n            },\n            serialized,\n            type,\n        });\n    const transaction = {\n        type,\n    };\n    if (Hex.validate(to) && to !== '0x')\n        transaction.to = to;\n    if (Hex.validate(gas) && gas !== '0x')\n        transaction.gas = BigInt(gas);\n    if (Hex.validate(data) && data !== '0x')\n        transaction.data = data;\n    if (Hex.validate(nonce) && nonce !== '0x')\n        transaction.nonce = BigInt(nonce);\n    if (Hex.validate(value) && value !== '0x')\n        transaction.value = BigInt(value);\n    if (Hex.validate(gasPrice) && gasPrice !== '0x')\n        transaction.gasPrice = BigInt(gasPrice);\n    if (tuple.length === 6)\n        return transaction;\n    const chainIdOrV = Hex.validate(chainIdOrV_) && chainIdOrV_ !== '0x'\n        ? Number(chainIdOrV_)\n        : 0;\n    if (s === '0x' && r === '0x') {\n        if (chainIdOrV > 0)\n            transaction.chainId = Number(chainIdOrV);\n        return transaction;\n    }\n    const v = chainIdOrV;\n    const chainId = Math.floor((v - 35) / 2);\n    if (chainId > 0)\n        transaction.chainId = chainId;\n    else if (v !== 27 && v !== 28)\n        throw new Signature.InvalidVError({ value: v });\n    transaction.yParity = Signature.vToYParity(v);\n    transaction.v = v;\n    transaction.s = s === '0x' ? 0n : BigInt(s);\n    transaction.r = r === '0x' ? 0n : BigInt(r);\n    assert(transaction);\n    return transaction;\n}\n/**\n * Converts an arbitrary transaction object into a legacy Transaction Envelope.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeLegacy, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from({\n *   gasPrice: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the transaction envelope.\n *\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeLegacy, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from({\n *   chainId: 1,\n *   gasPrice: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeLegacy.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const envelope_signed = TransactionEnvelopeLegacy.from(envelope, { // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * // @log: {\n * // @log:   authorizationList: [...],\n * // @log:   chainId: 1,\n * // @log:   gasPrice: 10000000000n,\n * // @log:   to: '0x0000000000000000000000000000000000000000',\n * // @log:   type: 'eip7702',\n * // @log:   value: 1000000000000000000n,\n * // @log:   r: 125...n,\n * // @log:   s: 642...n,\n * // @log:   yParity: 0,\n * // @log: }\n * ```\n *\n * @example\n * ### From Serialized\n *\n * It is possible to instantiate an legacy Transaction Envelope from a {@link ox#TransactionEnvelopeLegacy.Serialized} value.\n *\n * ```ts twoslash\n * import { TransactionEnvelopeLegacy } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from('0xf858018203118502540be4008504a817c800809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c08477359400e1a001627c687261b0e7f8638af1112efa8a77e23656f6e7945275b19e9deed80261')\n * // @log: {\n * // @log:   chainId: 1,\n * // @log:   gasPrice: 10000000000n,\n * // @log:   to: '0x0000000000000000000000000000000000000000',\n * // @log:   type: 'legacy',\n * // @log:   value: 1000000000000000000n,\n * // @log: }\n * ```\n *\n * @param envelope - The transaction object to convert.\n * @param options - Options.\n * @returns A legacy Transaction Envelope.\n */\nexport function from(envelope, options = {}) {\n    const { signature } = options;\n    const envelope_ = (typeof envelope === 'string' ? deserialize(envelope) : envelope);\n    assert(envelope_);\n    const signature_ = (() => {\n        if (!signature)\n            return {};\n        const s = Signature.from(signature);\n        s.v = Signature.yParityToV(s.yParity);\n        return s;\n    })();\n    return {\n        ...envelope_,\n        ...signature_,\n        type: 'legacy',\n    };\n}\n/**\n * Returns the payload to sign for a {@link ox#TransactionEnvelopeLegacy.TransactionEnvelopeLegacy}.\n *\n * @example\n * The example below demonstrates how to compute the sign payload which can be used\n * with ECDSA signing utilities like {@link ox#Secp256k1.(sign:function)}.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1, TransactionEnvelopeLegacy } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from({\n *   nonce: 0n,\n *   gasPrice: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const payload = TransactionEnvelopeLegacy.getSignPayload(envelope) // [!code focus]\n * // @log: '0x...'\n *\n * const signature = Secp256k1.sign({ payload, privateKey: '0x...' })\n * ```\n *\n * @param envelope - The transaction envelope to get the sign payload for.\n * @returns The sign payload.\n */\nexport function getSignPayload(envelope) {\n    return hash(envelope, { presign: true });\n}\n/**\n * Hashes a {@link ox#TransactionEnvelopeLegacy.TransactionEnvelopeLegacy}. This is the \"transaction hash\".\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeLegacy } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from({\n *   chainId: 1,\n *   nonce: 0n,\n *   gasPrice: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeLegacy.getSignPayload(envelope),\n *   privateKey: '0x...'\n * })\n *\n * const envelope_signed = TransactionEnvelopeLegacy.from(envelope, { signature })\n *\n * const hash = TransactionEnvelopeLegacy.hash(envelope_signed) // [!code focus]\n * ```\n *\n * @param envelope - The Legacy Transaction Envelope to hash.\n * @param options - Options.\n * @returns The hash of the transaction envelope.\n */\nexport function hash(envelope, options = {}) {\n    const { presign } = options;\n    return Hash.keccak256(serialize({\n        ...envelope,\n        ...(presign\n            ? {\n                r: undefined,\n                s: undefined,\n                yParity: undefined,\n                v: undefined,\n            }\n            : {}),\n    }));\n}\n/**\n * Serializes a {@link ox#TransactionEnvelopeLegacy.TransactionEnvelopeLegacy}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { TransactionEnvelopeLegacy } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from({\n *   chainId: 1,\n *   gasPrice: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const serialized = TransactionEnvelopeLegacy.serialize(envelope) // [!code focus]\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the serialized Transaction Envelope.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1, TransactionEnvelopeLegacy, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from({\n *   chainId: 1,\n *   gasPrice: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeLegacy.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const serialized = TransactionEnvelopeLegacy.serialize(envelope, { // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n *\n * // ... send `serialized` transaction to JSON-RPC `eth_sendRawTransaction`\n * ```\n *\n * @param envelope - The Transaction Envelope to serialize.\n * @param options - Options.\n * @returns The serialized Transaction Envelope.\n */\nexport function serialize(envelope, options = {}) {\n    const { chainId = 0, gas, data, input, nonce, to, value, gasPrice } = envelope;\n    assert(envelope);\n    let serialized = [\n        nonce ? Hex.fromNumber(nonce) : '0x',\n        gasPrice ? Hex.fromNumber(gasPrice) : '0x',\n        gas ? Hex.fromNumber(gas) : '0x',\n        to ?? '0x',\n        value ? Hex.fromNumber(value) : '0x',\n        data ?? input ?? '0x',\n    ];\n    const signature = (() => {\n        if (options.signature)\n            return {\n                r: options.signature.r,\n                s: options.signature.s,\n                v: Signature.yParityToV(options.signature.yParity),\n            };\n        if (typeof envelope.r === 'undefined' || typeof envelope.s === 'undefined')\n            return undefined;\n        return {\n            r: envelope.r,\n            s: envelope.s,\n            v: envelope.v,\n        };\n    })();\n    if (signature) {\n        const v = (() => {\n            // EIP-155 (inferred chainId)\n            if (signature.v >= 35) {\n                const inferredChainId = Math.floor((signature.v - 35) / 2);\n                if (inferredChainId > 0)\n                    return signature.v;\n                return 27 + (signature.v === 35 ? 0 : 1);\n            }\n            // EIP-155 (explicit chainId)\n            if (chainId > 0)\n                return chainId * 2 + 35 + signature.v - 27;\n            // Pre-EIP-155 (no chainId)\n            const v = 27 + (signature.v === 27 ? 0 : 1);\n            if (signature.v !== v)\n                throw new Signature.InvalidVError({ value: signature.v });\n            return v;\n        })();\n        serialized = [\n            ...serialized,\n            Hex.fromNumber(v),\n            signature.r === 0n ? '0x' : Hex.trimLeft(Hex.fromNumber(signature.r)),\n            signature.s === 0n ? '0x' : Hex.trimLeft(Hex.fromNumber(signature.s)),\n        ];\n    }\n    else if (chainId > 0)\n        serialized = [...serialized, Hex.fromNumber(chainId), '0x', '0x'];\n    return Rlp.fromHex(serialized);\n}\n/**\n * Converts an {@link ox#TransactionEnvelopeLegacy.TransactionEnvelopeLegacy} to an {@link ox#TransactionEnvelopeLegacy.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { RpcRequest, TransactionEnvelopeLegacy, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from({\n *   chainId: 1,\n *   nonce: 0n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: Value.fromEther('1'),\n * })\n *\n * const envelope_rpc = TransactionEnvelopeLegacy.toRpc(envelope) // [!code focus]\n *\n * const request = RpcRequest.from({\n *   id: 0,\n *   method: 'eth_sendTransaction',\n *   params: [envelope_rpc],\n * })\n * ```\n *\n * @param envelope - The legacy transaction envelope to convert.\n * @returns An RPC-formatted legacy transaction envelope.\n */\nexport function toRpc(envelope) {\n    const signature = Signature.extract(envelope);\n    return {\n        ...envelope,\n        chainId: typeof envelope.chainId === 'number'\n            ? Hex.fromNumber(envelope.chainId)\n            : undefined,\n        data: envelope.data ?? envelope.input,\n        type: '0x0',\n        ...(typeof envelope.gas === 'bigint'\n            ? { gas: Hex.fromNumber(envelope.gas) }\n            : {}),\n        ...(typeof envelope.nonce === 'bigint'\n            ? { nonce: Hex.fromNumber(envelope.nonce) }\n            : {}),\n        ...(typeof envelope.value === 'bigint'\n            ? { value: Hex.fromNumber(envelope.value) }\n            : {}),\n        ...(typeof envelope.gasPrice === 'bigint'\n            ? { gasPrice: Hex.fromNumber(envelope.gasPrice) }\n            : {}),\n        ...(signature\n            ? {\n                ...Signature.toRpc(signature),\n                v: signature.yParity === 0 ? '0x1b' : '0x1c',\n            }\n            : {}),\n    };\n}\n/**\n * Validates a {@link ox#TransactionEnvelopeLegacy.TransactionEnvelopeLegacy}. Returns `true` if the envelope is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeLegacy, Value } from 'ox'\n *\n * const valid = TransactionEnvelopeLegacy.assert({\n *   gasPrice: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * // @log: false\n * ```\n *\n * @param envelope - The transaction envelope to validate.\n */\nexport function validate(envelope) {\n    try {\n        assert(envelope);\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\n//# sourceMappingURL=TransactionEnvelopeLegacy.js.map","import * as AccessList from './AccessList.js';\nimport * as Address from './Address.js';\nimport * as Hash from './Hash.js';\nimport * as Hex from './Hex.js';\nimport * as Rlp from './Rlp.js';\nimport * as Signature from './Signature.js';\nimport * as TransactionEnvelope from './TransactionEnvelope.js';\nexport const serializedType = '0x02';\nexport const type = 'eip1559';\n/**\n * Asserts a {@link ox#TransactionEnvelopeEip1559.TransactionEnvelopeEip1559} is valid.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip1559, Value } from 'ox'\n *\n * TransactionEnvelopeEip1559.assert({\n *   maxFeePerGas: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * // @error: FeeCapTooHighError:\n * // @error: The fee cap (`masFeePerGas` = 115792089237316195423570985008687907853269984665640564039457584007913 gwei) cannot be\n * // @error: higher than the maximum allowed value (2^256-1).\n * ```\n *\n * @param envelope - The transaction envelope to assert.\n */\nexport function assert(envelope) {\n    const { chainId, maxPriorityFeePerGas, maxFeePerGas, to } = envelope;\n    if (chainId <= 0)\n        throw new TransactionEnvelope.InvalidChainIdError({ chainId });\n    if (to)\n        Address.assert(to, { strict: false });\n    if (maxFeePerGas && BigInt(maxFeePerGas) > 2n ** 256n - 1n)\n        throw new TransactionEnvelope.FeeCapTooHighError({ feeCap: maxFeePerGas });\n    if (maxPriorityFeePerGas &&\n        maxFeePerGas &&\n        maxPriorityFeePerGas > maxFeePerGas)\n        throw new TransactionEnvelope.TipAboveFeeCapError({\n            maxFeePerGas,\n            maxPriorityFeePerGas,\n        });\n}\n/**\n * Deserializes a {@link ox#TransactionEnvelopeEip1559.TransactionEnvelopeEip1559} from its serialized form.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip1559 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip1559.deserialize('0x02ef0182031184773594008477359400809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c0')\n * // @log: {\n * // @log:   type: 'eip1559',\n * // @log:   nonce: 785n,\n * // @log:   maxFeePerGas: 2000000000n,\n * // @log:   gas: 1000000n,\n * // @log:   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n * // @log:   value: 1000000000000000000n,\n * // @log: }\n * ```\n *\n * @param serialized - The serialized transaction.\n * @returns Deserialized Transaction Envelope.\n */\nexport function deserialize(serialized) {\n    const transactionArray = Rlp.toHex(Hex.slice(serialized, 1));\n    const [chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gas, to, value, data, accessList, yParity, r, s,] = transactionArray;\n    if (!(transactionArray.length === 9 || transactionArray.length === 12))\n        throw new TransactionEnvelope.InvalidSerializedError({\n            attributes: {\n                chainId,\n                nonce,\n                maxPriorityFeePerGas,\n                maxFeePerGas,\n                gas,\n                to,\n                value,\n                data,\n                accessList,\n                ...(transactionArray.length > 9\n                    ? {\n                        yParity,\n                        r,\n                        s,\n                    }\n                    : {}),\n            },\n            serialized,\n            type,\n        });\n    let transaction = {\n        chainId: Number(chainId),\n        type,\n    };\n    if (Hex.validate(to) && to !== '0x')\n        transaction.to = to;\n    if (Hex.validate(gas) && gas !== '0x')\n        transaction.gas = BigInt(gas);\n    if (Hex.validate(data) && data !== '0x')\n        transaction.data = data;\n    if (Hex.validate(nonce) && nonce !== '0x')\n        transaction.nonce = BigInt(nonce);\n    if (Hex.validate(value) && value !== '0x')\n        transaction.value = BigInt(value);\n    if (Hex.validate(maxFeePerGas) && maxFeePerGas !== '0x')\n        transaction.maxFeePerGas = BigInt(maxFeePerGas);\n    if (Hex.validate(maxPriorityFeePerGas) && maxPriorityFeePerGas !== '0x')\n        transaction.maxPriorityFeePerGas = BigInt(maxPriorityFeePerGas);\n    if (accessList.length !== 0 && accessList !== '0x')\n        transaction.accessList = AccessList.fromTupleList(accessList);\n    const signature = r && s && yParity ? Signature.fromTuple([yParity, r, s]) : undefined;\n    if (signature)\n        transaction = {\n            ...transaction,\n            ...signature,\n        };\n    assert(transaction);\n    return transaction;\n}\n/**\n * Converts an arbitrary transaction object into an EIP-1559 Transaction Envelope.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip1559, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip1559.from({\n *   chainId: 1,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the transaction envelope.\n *\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeEip1559, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip1559.from({\n *   chainId: 1,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip1559.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const envelope_signed = TransactionEnvelopeEip1559.from(envelope, { // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * // @log: {\n * // @log:   chainId: 1,\n * // @log:   maxFeePerGas: 10000000000n,\n * // @log:   maxPriorityFeePerGas: 1000000000n,\n * // @log:   to: '0x0000000000000000000000000000000000000000',\n * // @log:   type: 'eip1559',\n * // @log:   value: 1000000000000000000n,\n * // @log:   r: 125...n,\n * // @log:   s: 642...n,\n * // @log:   yParity: 0,\n * // @log: }\n * ```\n *\n * @example\n * ### From Serialized\n *\n * It is possible to instantiate an EIP-1559 Transaction Envelope from a {@link ox#TransactionEnvelopeEip1559.Serialized} value.\n *\n * ```ts twoslash\n * import { TransactionEnvelopeEip1559 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip1559.from('0x02f858018203118502540be4008504a817c800809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c08477359400e1a001627c687261b0e7f8638af1112efa8a77e23656f6e7945275b19e9deed80261')\n * // @log: {\n * // @log:   chainId: 1,\n * // @log:   maxFeePerGas: 10000000000n,\n * // @log:   maxPriorityFeePerGas: 1000000000n,\n * // @log:   to: '0x0000000000000000000000000000000000000000',\n * // @log:   type: 'eip1559',\n * // @log:   value: 1000000000000000000n,\n * // @log: }\n * ```\n *\n * @param envelope - The transaction object to convert.\n * @param options - Options.\n * @returns An EIP-1559 Transaction Envelope.\n */\nexport function from(envelope, options = {}) {\n    const { signature } = options;\n    const envelope_ = (typeof envelope === 'string' ? deserialize(envelope) : envelope);\n    assert(envelope_);\n    return {\n        ...envelope_,\n        ...(signature ? Signature.from(signature) : {}),\n        type: 'eip1559',\n    };\n}\n/**\n * Returns the payload to sign for a {@link ox#TransactionEnvelopeEip1559.TransactionEnvelopeEip1559}.\n *\n * @example\n * The example below demonstrates how to compute the sign payload which can be used\n * with ECDSA signing utilities like {@link ox#Secp256k1.(sign:function)}.\n *\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeEip1559 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip1559.from({\n *   chainId: 1,\n *   nonce: 0n,\n *   maxFeePerGas: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const payload = TransactionEnvelopeEip1559.getSignPayload(envelope) // [!code focus]\n * // @log: '0x...'\n *\n * const signature = Secp256k1.sign({ payload, privateKey: '0x...' })\n * ```\n *\n * @param envelope - The transaction envelope to get the sign payload for.\n * @returns The sign payload.\n */\nexport function getSignPayload(envelope) {\n    return hash(envelope, { presign: true });\n}\n/**\n * Hashes a {@link ox#TransactionEnvelopeEip1559.TransactionEnvelopeEip1559}. This is the \"transaction hash\".\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeEip1559 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip1559.from({\n *   chainId: 1,\n *   nonce: 0n,\n *   maxFeePerGas: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip1559.getSignPayload(envelope),\n *   privateKey: '0x...'\n * })\n *\n * const envelope_signed = TransactionEnvelopeEip1559.from(envelope, { signature })\n *\n * const hash = TransactionEnvelopeEip1559.hash(envelope_signed) // [!code focus]\n * ```\n *\n * @param envelope - The EIP-1559 Transaction Envelope to hash.\n * @param options - Options.\n * @returns The hash of the transaction envelope.\n */\nexport function hash(envelope, options = {}) {\n    const { presign } = options;\n    return Hash.keccak256(serialize({\n        ...envelope,\n        ...(presign\n            ? {\n                r: undefined,\n                s: undefined,\n                yParity: undefined,\n                v: undefined,\n            }\n            : {}),\n    }));\n}\n/**\n * Serializes a {@link ox#TransactionEnvelopeEip1559.TransactionEnvelopeEip1559}.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip1559, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip1559.from({\n *   chainId: 1,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const serialized = TransactionEnvelopeEip1559.serialize(envelope) // [!code focus]\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the serialized Transaction Envelope.\n *\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeEip1559, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip1559.from({\n *   chainId: 1,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip1559.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const serialized = TransactionEnvelopeEip1559.serialize(envelope, { // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n *\n * // ... send `serialized` transaction to JSON-RPC `eth_sendRawTransaction`\n * ```\n *\n * @param envelope - The Transaction Envelope to serialize.\n * @param options - Options.\n * @returns The serialized Transaction Envelope.\n */\nexport function serialize(envelope, options = {}) {\n    const { chainId, gas, nonce, to, value, maxFeePerGas, maxPriorityFeePerGas, accessList, data, input, } = envelope;\n    assert(envelope);\n    const accessTupleList = AccessList.toTupleList(accessList);\n    const signature = Signature.extract(options.signature || envelope);\n    const serialized = [\n        Hex.fromNumber(chainId),\n        nonce ? Hex.fromNumber(nonce) : '0x',\n        maxPriorityFeePerGas ? Hex.fromNumber(maxPriorityFeePerGas) : '0x',\n        maxFeePerGas ? Hex.fromNumber(maxFeePerGas) : '0x',\n        gas ? Hex.fromNumber(gas) : '0x',\n        to ?? '0x',\n        value ? Hex.fromNumber(value) : '0x',\n        data ?? input ?? '0x',\n        accessTupleList,\n        ...(signature ? Signature.toTuple(signature) : []),\n    ];\n    return Hex.concat(serializedType, Rlp.fromHex(serialized));\n}\n/**\n * Converts an {@link ox#TransactionEnvelopeEip1559.TransactionEnvelopeEip1559} to an {@link ox#TransactionEnvelopeEip1559.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { RpcRequest, TransactionEnvelopeEip1559, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip1559.from({\n *   chainId: 1,\n *   nonce: 0n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: Value.fromEther('1'),\n * })\n *\n * const envelope_rpc = TransactionEnvelopeEip1559.toRpc(envelope) // [!code focus]\n *\n * const request = RpcRequest.from({\n *   id: 0,\n *   method: 'eth_sendTransaction',\n *   params: [envelope_rpc],\n * })\n * ```\n *\n * @param envelope - The EIP-1559 transaction envelope to convert.\n * @returns An RPC-formatted EIP-1559 transaction envelope.\n */\nexport function toRpc(envelope) {\n    const signature = Signature.extract(envelope);\n    return {\n        ...envelope,\n        chainId: Hex.fromNumber(envelope.chainId),\n        data: envelope.data ?? envelope.input,\n        type: '0x2',\n        ...(typeof envelope.gas === 'bigint'\n            ? { gas: Hex.fromNumber(envelope.gas) }\n            : {}),\n        ...(typeof envelope.nonce === 'bigint'\n            ? { nonce: Hex.fromNumber(envelope.nonce) }\n            : {}),\n        ...(typeof envelope.value === 'bigint'\n            ? { value: Hex.fromNumber(envelope.value) }\n            : {}),\n        ...(typeof envelope.maxFeePerGas === 'bigint'\n            ? { maxFeePerGas: Hex.fromNumber(envelope.maxFeePerGas) }\n            : {}),\n        ...(typeof envelope.maxPriorityFeePerGas === 'bigint'\n            ? {\n                maxPriorityFeePerGas: Hex.fromNumber(envelope.maxPriorityFeePerGas),\n            }\n            : {}),\n        ...(signature ? Signature.toRpc(signature) : {}),\n    };\n}\n/**\n * Validates a {@link ox#TransactionEnvelopeEip1559.TransactionEnvelopeEip1559}. Returns `true` if the envelope is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip1559, Value } from 'ox'\n *\n * const valid = TransactionEnvelopeEip1559.assert({\n *   maxFeePerGas: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * // @log: false\n * ```\n *\n * @param envelope - The transaction envelope to validate.\n */\nexport function validate(envelope) {\n    try {\n        assert(envelope);\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\n//# sourceMappingURL=TransactionEnvelopeEip1559.js.map","import * as AccessList from './AccessList.js';\nimport * as Address from './Address.js';\nimport * as Hash from './Hash.js';\nimport * as Hex from './Hex.js';\nimport * as Rlp from './Rlp.js';\nimport * as Signature from './Signature.js';\nimport * as TransactionEnvelope from './TransactionEnvelope.js';\nexport const serializedType = '0x01';\nexport const type = 'eip2930';\n/**\n * Asserts a {@link ox#TransactionEnvelopeEip2930.TransactionEnvelopeEip2930} is valid.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip2930, Value } from 'ox'\n *\n * TransactionEnvelopeEip2930.assert({\n *   gasPrice: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * // @error: GasPriceTooHighError:\n * // @error: The gas price (`gasPrice` = 115792089237316195423570985008687907853269984665640564039457584007913 gwei) cannot be\n * // @error: higher than the maximum allowed value (2^256-1).\n * ```\n *\n * @param envelope - The transaction envelope to assert.\n */\nexport function assert(envelope) {\n    const { chainId, gasPrice, to } = envelope;\n    if (chainId <= 0)\n        throw new TransactionEnvelope.InvalidChainIdError({ chainId });\n    if (to)\n        Address.assert(to, { strict: false });\n    if (gasPrice && BigInt(gasPrice) > 2n ** 256n - 1n)\n        throw new TransactionEnvelope.GasPriceTooHighError({ gasPrice });\n}\n/**\n * Deserializes a {@link ox#TransactionEnvelopeEip2930.TransactionEnvelopeEip2930} from its serialized form.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip2930 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip2930.deserialize('0x01ef0182031184773594008477359400809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c0')\n * // @log: {\n * // @log:   type: 'eip2930',\n * // @log:   nonce: 785n,\n * // @log:   gasPrice: 2000000000n,\n * // @log:   gas: 1000000n,\n * // @log:   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n * // @log:   value: 1000000000000000000n,\n * // @log: }\n * ```\n *\n * @param serialized - The serialized transaction.\n * @returns Deserialized Transaction Envelope.\n */\nexport function deserialize(serialized) {\n    const transactionArray = Rlp.toHex(Hex.slice(serialized, 1));\n    const [chainId, nonce, gasPrice, gas, to, value, data, accessList, yParity, r, s,] = transactionArray;\n    if (!(transactionArray.length === 8 || transactionArray.length === 11))\n        throw new TransactionEnvelope.InvalidSerializedError({\n            attributes: {\n                chainId,\n                nonce,\n                gasPrice,\n                gas,\n                to,\n                value,\n                data,\n                accessList,\n                ...(transactionArray.length > 8\n                    ? {\n                        yParity,\n                        r,\n                        s,\n                    }\n                    : {}),\n            },\n            serialized,\n            type,\n        });\n    let transaction = {\n        chainId: Number(chainId),\n        type,\n    };\n    if (Hex.validate(to) && to !== '0x')\n        transaction.to = to;\n    if (Hex.validate(gas) && gas !== '0x')\n        transaction.gas = BigInt(gas);\n    if (Hex.validate(data) && data !== '0x')\n        transaction.data = data;\n    if (Hex.validate(nonce) && nonce !== '0x')\n        transaction.nonce = BigInt(nonce);\n    if (Hex.validate(value) && value !== '0x')\n        transaction.value = BigInt(value);\n    if (Hex.validate(gasPrice) && gasPrice !== '0x')\n        transaction.gasPrice = BigInt(gasPrice);\n    if (accessList.length !== 0 && accessList !== '0x')\n        transaction.accessList = AccessList.fromTupleList(accessList);\n    const signature = r && s && yParity ? Signature.fromTuple([yParity, r, s]) : undefined;\n    if (signature)\n        transaction = {\n            ...transaction,\n            ...signature,\n        };\n    assert(transaction);\n    return transaction;\n}\n/**\n * Converts an arbitrary transaction object into an EIP-2930 Transaction Envelope.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { TransactionEnvelopeEip2930, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip2930.from({\n *   chainId: 1,\n *   accessList: [...],\n *   gasPrice: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the transaction envelope.\n *\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeEip2930, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip2930.from({\n *   chainId: 1,\n *   gasPrice: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip2930.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const envelope_signed = TransactionEnvelopeEip2930.from(envelope, { // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * // @log: {\n * // @log:   chainId: 1,\n * // @log:   gasPrice: 10000000000n,\n * // @log:   to: '0x0000000000000000000000000000000000000000',\n * // @log:   type: 'eip2930',\n * // @log:   value: 1000000000000000000n,\n * // @log:   r: 125...n,\n * // @log:   s: 642...n,\n * // @log:   yParity: 0,\n * // @log: }\n * ```\n *\n * @example\n * ### From Serialized\n *\n * It is possible to instantiate an EIP-2930 Transaction Envelope from a {@link ox#TransactionEnvelopeEip2930.Serialized} value.\n *\n * ```ts twoslash\n * import { TransactionEnvelopeEip2930 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip2930.from('0x01f858018203118502540be4008504a817c800809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c08477359400e1a001627c687261b0e7f8638af1112efa8a77e23656f6e7945275b19e9deed80261')\n * // @log: {\n * // @log:   chainId: 1,\n * // @log:   gasPrice: 10000000000n,\n * // @log:   to: '0x0000000000000000000000000000000000000000',\n * // @log:   type: 'eip2930',\n * // @log:   value: 1000000000000000000n,\n * // @log: }\n * ```\n *\n * @param envelope - The transaction object to convert.\n * @param options - Options.\n * @returns A {@link ox#TransactionEnvelopeEip2930.TransactionEnvelopeEip2930}\n */\nexport function from(envelope, options = {}) {\n    const { signature } = options;\n    const envelope_ = (typeof envelope === 'string' ? deserialize(envelope) : envelope);\n    assert(envelope_);\n    return {\n        ...envelope_,\n        ...(signature ? Signature.from(signature) : {}),\n        type: 'eip2930',\n    };\n}\n/**\n * Returns the payload to sign for a {@link ox#TransactionEnvelopeEip2930.TransactionEnvelopeEip2930}.\n *\n * @example\n * The example below demonstrates how to compute the sign payload which can be used\n * with ECDSA signing utilities like {@link ox#Secp256k1.(sign:function)}.\n *\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeEip2930 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip2930.from({\n *   chainId: 1,\n *   nonce: 0n,\n *   gasPrice: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const payload = TransactionEnvelopeEip2930.getSignPayload(envelope) // [!code focus]\n * // @log: '0x...'\n *\n * const signature = Secp256k1.sign({ payload, privateKey: '0x...' })\n * ```\n *\n * @param envelope - The transaction envelope to get the sign payload for.\n * @returns The sign payload.\n */\nexport function getSignPayload(envelope) {\n    return hash(envelope, { presign: true });\n}\n/**\n * Hashes a {@link ox#TransactionEnvelopeEip2930.TransactionEnvelopeEip2930}. This is the \"transaction hash\".\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeEip2930 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip2930.from({\n *   chainId: 1,\n *   nonce: 0n,\n *   gasPrice: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip2930.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const envelope_signed = TransactionEnvelopeEip2930.from(envelope, {\n *   signature,\n * })\n *\n * const hash = TransactionEnvelopeEip2930.hash(envelope_signed) // [!code focus]\n * ```\n *\n * @param envelope - The EIP-2930 Transaction Envelope to hash.\n * @param options - Options.\n * @returns The hash of the transaction envelope.\n */\nexport function hash(envelope, options = {}) {\n    const { presign } = options;\n    return Hash.keccak256(serialize({\n        ...envelope,\n        ...(presign\n            ? {\n                r: undefined,\n                s: undefined,\n                yParity: undefined,\n                v: undefined,\n            }\n            : {}),\n    }));\n}\n/**\n * Serializes a {@link ox#TransactionEnvelopeEip2930.TransactionEnvelopeEip2930}.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip2930, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip2930.from({\n *   chainId: 1,\n *   gasPrice: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const serialized = TransactionEnvelopeEip2930.serialize(envelope) // [!code focus]\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the serialized Transaction Envelope.\n *\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeEip2930, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip2930.from({\n *   chainId: 1,\n *   gasPrice: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip2930.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const serialized = TransactionEnvelopeEip2930.serialize(envelope, { // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n *\n * // ... send `serialized` transaction to JSON-RPC `eth_sendRawTransaction`\n * ```\n *\n * @param envelope - The Transaction Envelope to serialize.\n * @param options - Options.\n * @returns The serialized Transaction Envelope.\n */\nexport function serialize(envelope, options = {}) {\n    const { chainId, gas, data, input, nonce, to, value, accessList, gasPrice } = envelope;\n    assert(envelope);\n    const accessTupleList = AccessList.toTupleList(accessList);\n    const signature = Signature.extract(options.signature || envelope);\n    const serialized = [\n        Hex.fromNumber(chainId),\n        nonce ? Hex.fromNumber(nonce) : '0x',\n        gasPrice ? Hex.fromNumber(gasPrice) : '0x',\n        gas ? Hex.fromNumber(gas) : '0x',\n        to ?? '0x',\n        value ? Hex.fromNumber(value) : '0x',\n        data ?? input ?? '0x',\n        accessTupleList,\n        ...(signature ? Signature.toTuple(signature) : []),\n    ];\n    return Hex.concat('0x01', Rlp.fromHex(serialized));\n}\n/**\n * Converts an {@link ox#TransactionEnvelopeEip2930.TransactionEnvelopeEip2930} to an {@link ox#TransactionEnvelopeEip2930.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { RpcRequest, TransactionEnvelopeEip2930, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip2930.from({\n *   chainId: 1,\n *   nonce: 0n,\n *   gas: 21000n,\n *   maxFeePerGas: Value.fromGwei('20'),\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: Value.fromEther('1'),\n * })\n *\n * const envelope_rpc = TransactionEnvelopeEip2930.toRpc(envelope) // [!code focus]\n *\n * const request = RpcRequest.from({\n *   id: 0,\n *   method: 'eth_sendTransaction',\n *   params: [envelope_rpc],\n * })\n * ```\n *\n * @param envelope - The EIP-2930 transaction envelope to convert.\n * @returns An RPC-formatted EIP-2930 transaction envelope.\n */\nexport function toRpc(envelope) {\n    const signature = Signature.extract(envelope);\n    return {\n        ...envelope,\n        chainId: Hex.fromNumber(envelope.chainId),\n        data: envelope.data ?? envelope.input,\n        ...(typeof envelope.gas === 'bigint'\n            ? { gas: Hex.fromNumber(envelope.gas) }\n            : {}),\n        ...(typeof envelope.nonce === 'bigint'\n            ? { nonce: Hex.fromNumber(envelope.nonce) }\n            : {}),\n        ...(typeof envelope.value === 'bigint'\n            ? { value: Hex.fromNumber(envelope.value) }\n            : {}),\n        ...(typeof envelope.gasPrice === 'bigint'\n            ? { gasPrice: Hex.fromNumber(envelope.gasPrice) }\n            : {}),\n        type: '0x1',\n        ...(signature ? Signature.toRpc(signature) : {}),\n    };\n}\n/**\n * Validates a {@link ox#TransactionEnvelopeEip2930.TransactionEnvelopeEip2930}. Returns `true` if the envelope is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip2930, Value } from 'ox'\n *\n * const valid = TransactionEnvelopeEip2930.assert({\n *   gasPrice: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * // @log: false\n * ```\n *\n * @param envelope - The transaction envelope to validate.\n */\nexport function validate(envelope) {\n    try {\n        assert(envelope);\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\n//# sourceMappingURL=TransactionEnvelopeEip2930.js.map","import * as AccessList from './AccessList.js';\nimport * as Address from './Address.js';\nimport * as Authorization from './Authorization.js';\nimport * as Hash from './Hash.js';\nimport * as Hex from './Hex.js';\nimport * as Rlp from './Rlp.js';\nimport * as Signature from './Signature.js';\nimport * as TransactionEnvelope from './TransactionEnvelope.js';\nimport * as TransactionEnvelopeEip1559 from './TransactionEnvelopeEip1559.js';\nexport const serializedType = '0x04';\nexport const type = 'eip7702';\n/**\n * Asserts a {@link ox#TransactionEnvelopeEip7702.TransactionEnvelopeEip7702} is valid.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip7702, Value } from 'ox'\n *\n * TransactionEnvelopeEip7702.assert({\n *   authorizationList: [],\n *   maxFeePerGas: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * // @error: FeeCapTooHighError:\n * // @error: The fee cap (`masFeePerGas` = 115792089237316195423570985008687907853269984665640564039457584007913 gwei) cannot be\n * // @error: higher than the maximum allowed value (2^256-1).\n * ```\n *\n * @param envelope - The transaction envelope to assert.\n */\nexport function assert(envelope) {\n    const { authorizationList } = envelope;\n    if (authorizationList) {\n        for (const authorization of authorizationList) {\n            const { address, chainId } = authorization;\n            if (address)\n                Address.assert(address, { strict: false });\n            if (Number(chainId) < 0)\n                throw new TransactionEnvelope.InvalidChainIdError({ chainId });\n        }\n    }\n    TransactionEnvelopeEip1559.assert(envelope);\n}\n/**\n * Deserializes a {@link ox#TransactionEnvelopeEip7702.TransactionEnvelopeEip7702} from its serialized form.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip7702 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip7702.deserialize('0x04ef0182031184773594008477359400809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c0')\n * // @log: {\n * // @log:   authorizationList: [...],\n * // @log:   type: 'eip7702',\n * // @log:   nonce: 785n,\n * // @log:   maxFeePerGas: 2000000000n,\n * // @log:   gas: 1000000n,\n * // @log:   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n * // @log:   value: 1000000000000000000n,\n * // @log: }\n * ```\n *\n * @param serialized - The serialized transaction.\n * @returns Deserialized Transaction Envelope.\n */\nexport function deserialize(serialized) {\n    const transactionArray = Rlp.toHex(Hex.slice(serialized, 1));\n    const [chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gas, to, value, data, accessList, authorizationList, yParity, r, s,] = transactionArray;\n    if (!(transactionArray.length === 10 || transactionArray.length === 13))\n        throw new TransactionEnvelope.InvalidSerializedError({\n            attributes: {\n                chainId,\n                nonce,\n                maxPriorityFeePerGas,\n                maxFeePerGas,\n                gas,\n                to,\n                value,\n                data,\n                accessList,\n                authorizationList,\n                ...(transactionArray.length > 9\n                    ? {\n                        yParity,\n                        r,\n                        s,\n                    }\n                    : {}),\n            },\n            serialized,\n            type,\n        });\n    let transaction = {\n        chainId: Number(chainId),\n        type,\n    };\n    if (Hex.validate(to) && to !== '0x')\n        transaction.to = to;\n    if (Hex.validate(gas) && gas !== '0x')\n        transaction.gas = BigInt(gas);\n    if (Hex.validate(data) && data !== '0x')\n        transaction.data = data;\n    if (Hex.validate(nonce) && nonce !== '0x')\n        transaction.nonce = BigInt(nonce);\n    if (Hex.validate(value) && value !== '0x')\n        transaction.value = BigInt(value);\n    if (Hex.validate(maxFeePerGas) && maxFeePerGas !== '0x')\n        transaction.maxFeePerGas = BigInt(maxFeePerGas);\n    if (Hex.validate(maxPriorityFeePerGas) && maxPriorityFeePerGas !== '0x')\n        transaction.maxPriorityFeePerGas = BigInt(maxPriorityFeePerGas);\n    if (accessList.length !== 0 && accessList !== '0x')\n        transaction.accessList = AccessList.fromTupleList(accessList);\n    if (authorizationList !== '0x')\n        transaction.authorizationList = Authorization.fromTupleList(authorizationList);\n    const signature = r && s && yParity ? Signature.fromTuple([yParity, r, s]) : undefined;\n    if (signature)\n        transaction = {\n            ...transaction,\n            ...signature,\n        };\n    assert(transaction);\n    return transaction;\n}\n/**\n * Converts an arbitrary transaction object into an EIP-7702 Transaction Envelope.\n *\n * @example\n * ```ts twoslash\n * import { Authorization, Secp256k1, TransactionEnvelopeEip7702, Value } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   chainId: 1,\n *   nonce: 0n,\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: Authorization.getSignPayload(authorization),\n *   privateKey: '0x...',\n * })\n *\n * const authorizationList = [Authorization.from(authorization, { signature })]\n *\n * const envelope = TransactionEnvelopeEip7702.from({ // [!code focus]\n *   authorizationList, // [!code focus]\n *   chainId: 1, // [!code focus]\n *   maxFeePerGas: Value.fromGwei('10'), // [!code focus]\n *   maxPriorityFeePerGas: Value.fromGwei('1'), // [!code focus]\n *   to: '0x0000000000000000000000000000000000000000', // [!code focus]\n *   value: Value.fromEther('1'), // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the transaction envelope.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1, TransactionEnvelopeEip7702, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip7702.from({\n *   authorizationList: [...],\n *   chainId: 1,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip7702.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const envelope_signed = TransactionEnvelopeEip7702.from(envelope, { // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * // @log: {\n * // @log:   authorizationList: [...],\n * // @log:   chainId: 1,\n * // @log:   maxFeePerGas: 10000000000n,\n * // @log:   maxPriorityFeePerGas: 1000000000n,\n * // @log:   to: '0x0000000000000000000000000000000000000000',\n * // @log:   type: 'eip7702',\n * // @log:   value: 1000000000000000000n,\n * // @log:   r: 125...n,\n * // @log:   s: 642...n,\n * // @log:   yParity: 0,\n * // @log: }\n * ```\n *\n * @example\n * ### From Serialized\n *\n * It is possible to instantiate an EIP-7702 Transaction Envelope from a {@link ox#TransactionEnvelopeEip7702.Serialized} value.\n *\n * ```ts twoslash\n * import { TransactionEnvelopeEip7702 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip7702.from('0x04f858018203118502540be4008504a817c800809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c08477359400e1a001627c687261b0e7f8638af1112efa8a77e23656f6e7945275b19e9deed80261')\n * // @log: {\n * // @log:   authorizationList: [...],\n * // @log:   chainId: 1,\n * // @log:   maxFeePerGas: 10000000000n,\n * // @log:   to: '0x0000000000000000000000000000000000000000',\n * // @log:   type: 'eip7702',\n * // @log:   value: 1000000000000000000n,\n * // @log: }\n * ```\n *\n * @param envelope - The transaction object to convert.\n * @param options - Options.\n * @returns An EIP-7702 Transaction Envelope.\n */\nexport function from(envelope, options = {}) {\n    const { signature } = options;\n    const envelope_ = (typeof envelope === 'string' ? deserialize(envelope) : envelope);\n    assert(envelope_);\n    return {\n        ...envelope_,\n        ...(signature ? Signature.from(signature) : {}),\n        type: 'eip7702',\n    };\n}\n/**\n * Returns the payload to sign for a {@link ox#TransactionEnvelopeEip7702.TransactionEnvelopeEip7702}.\n *\n * @example\n * The example below demonstrates how to compute the sign payload which can be used\n * with ECDSA signing utilities like {@link ox#Secp256k1.(sign:function)}.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1, TransactionEnvelopeEip7702 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip7702.from({\n *   authorizationList: [...],\n *   chainId: 1,\n *   nonce: 0n,\n *   maxFeePerGas: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const payload = TransactionEnvelopeEip7702.getSignPayload(envelope) // [!code focus]\n * // @log: '0x...'\n *\n * const signature = Secp256k1.sign({ payload, privateKey: '0x...' })\n * ```\n *\n * @param envelope - The transaction envelope to get the sign payload for.\n * @returns The sign payload.\n */\nexport function getSignPayload(envelope) {\n    return hash(envelope, { presign: true });\n}\n/**\n * Hashes a {@link ox#TransactionEnvelopeEip7702.TransactionEnvelopeEip7702}. This is the \"transaction hash\".\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1, TransactionEnvelopeEip7702 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip7702.from({\n *   authorizationList: [...],\n *   chainId: 1,\n *   nonce: 0n,\n *   maxFeePerGas: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip7702.getSignPayload(envelope),\n *   privateKey: '0x...'\n * })\n *\n * const envelope_signed = TransactionEnvelopeEip7702.from(envelope, { signature })\n *\n * const hash = TransactionEnvelopeEip7702.hash(envelope_signed) // [!code focus]\n * ```\n *\n * @param envelope - The EIP-7702 Transaction Envelope to hash.\n * @param options - Options.\n * @returns The hash of the transaction envelope.\n */\nexport function hash(envelope, options = {}) {\n    const { presign } = options;\n    return Hash.keccak256(serialize({\n        ...envelope,\n        ...(presign\n            ? {\n                r: undefined,\n                s: undefined,\n                yParity: undefined,\n            }\n            : {}),\n    }));\n}\n/**\n * Serializes a {@link ox#TransactionEnvelopeEip7702.TransactionEnvelopeEip7702}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Authorization, Secp256k1, TransactionEnvelopeEip7702, Value } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   chainId: 1,\n *   nonce: 0n,\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: Authorization.getSignPayload(authorization),\n *   privateKey: '0x...',\n * })\n *\n * const authorizationList = [Authorization.from(authorization, { signature })]\n *\n * const envelope = TransactionEnvelopeEip7702.from({\n *   authorizationList,\n *   chainId: 1,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const serialized = TransactionEnvelopeEip7702.serialize(envelope) // [!code focus]\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the serialized Transaction Envelope.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1, TransactionEnvelopeEip7702, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip7702.from({\n *   authorizationList: [...],\n *   chainId: 1,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip7702.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const serialized = TransactionEnvelopeEip7702.serialize(envelope, { // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n *\n * // ... send `serialized` transaction to JSON-RPC `eth_sendRawTransaction`\n * ```\n *\n * @param envelope - The Transaction Envelope to serialize.\n * @param options - Options.\n * @returns The serialized Transaction Envelope.\n */\nexport function serialize(envelope, options = {}) {\n    const { authorizationList, chainId, gas, nonce, to, value, maxFeePerGas, maxPriorityFeePerGas, accessList, data, input, } = envelope;\n    assert(envelope);\n    const accessTupleList = AccessList.toTupleList(accessList);\n    const authorizationTupleList = Authorization.toTupleList(authorizationList);\n    const signature = Signature.extract(options.signature || envelope);\n    const serialized = [\n        Hex.fromNumber(chainId),\n        nonce ? Hex.fromNumber(nonce) : '0x',\n        maxPriorityFeePerGas ? Hex.fromNumber(maxPriorityFeePerGas) : '0x',\n        maxFeePerGas ? Hex.fromNumber(maxFeePerGas) : '0x',\n        gas ? Hex.fromNumber(gas) : '0x',\n        to ?? '0x',\n        value ? Hex.fromNumber(value) : '0x',\n        data ?? input ?? '0x',\n        accessTupleList,\n        authorizationTupleList,\n        ...(signature ? Signature.toTuple(signature) : []),\n    ];\n    return Hex.concat(serializedType, Rlp.fromHex(serialized));\n}\n/**\n * Validates a {@link ox#TransactionEnvelopeEip7702.TransactionEnvelopeEip7702}. Returns `true` if the envelope is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip7702, Value } from 'ox'\n *\n * const valid = TransactionEnvelopeEip7702.validate({\n *   authorizationList: [],\n *   maxFeePerGas: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * // @log: false\n * ```\n *\n * @param envelope - The transaction envelope to validate.\n */\nexport function validate(envelope) {\n    try {\n        assert(envelope);\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\n//# sourceMappingURL=TransactionEnvelopeEip7702.js.map","import * as ox__Hex from \"ox/Hex\";\nimport * as ox__Signature from \"ox/Signature\";\nimport * as ox__TransactionEnvelopeEip1559 from \"ox/TransactionEnvelopeEip1559\";\nimport * as ox__TransactionEnvelopeEip2930 from \"ox/TransactionEnvelopeEip2930\";\nimport * as ox__TransactionEnvelopeEip7702 from \"ox/TransactionEnvelopeEip7702\";\nimport * as ox__TransactionEnvelopeLegacy from \"ox/TransactionEnvelopeLegacy\";\n/**\n * Serializes a legacy, EIP-1559, EIP-2930, EIP-4844, or EIP-7702 transaction object.\n *\n * @param options - The serialization options.\n * @param options.transaction - The transaction object to be serialized.\n * @param [options.signature] - The signature to include with the transaction, if necessary.\n * @returns The serialized transaction.\n * @throws An error if the provided transaction object is invalid.\n * @transaction\n * @example\n * ```ts\n * import { serializeTransaction } from \"thirdweb\";\n *\n * const serializedTransaction = serializeTransaction({ transaction: {\n *    to: \"0x\",\n *    value: 0n,\n *  }\n * });\n * ```\n */\nexport function serializeTransaction(options) {\n    const { transaction } = options;\n    const type = getTransactionEnvelopeType(transaction);\n    // This is to maintain compatibility with our old interface (including the signature in the transaction object)\n    const signature = (() => {\n        if (options.signature) {\n            if (\"v\" in options.signature &&\n                typeof options.signature.v !== \"undefined\") {\n                return ox__Signature.fromLegacy({\n                    r: ox__Hex.toBigInt(options.signature.r),\n                    s: ox__Hex.toBigInt(options.signature.s),\n                    v: Number(options.signature.v),\n                });\n            }\n            return {\n                r: ox__Hex.toBigInt(options.signature.r),\n                s: ox__Hex.toBigInt(options.signature.s),\n                // We force the Signature type here because we filter for legacy type above\n                yParity: options.signature\n                    .yParity,\n            };\n        }\n        if (typeof transaction.v === \"undefined\" &&\n            typeof transaction.yParity === \"undefined\") {\n            return undefined;\n        }\n        if (transaction.r === undefined || transaction.s === undefined) {\n            throw new Error(\"Invalid signature provided with transaction\");\n        }\n        return {\n            r: typeof transaction.r === \"bigint\"\n                ? transaction.r\n                : ox__Hex.toBigInt(transaction.r),\n            s: typeof transaction.s === \"bigint\"\n                ? transaction.s\n                : ox__Hex.toBigInt(transaction.s),\n            yParity: typeof transaction.v !== \"undefined\" &&\n                typeof transaction.yParity === \"undefined\"\n                ? ox__Signature.vToYParity(Number(transaction.v))\n                : Number(transaction.yParity),\n        };\n    })();\n    if (type === \"eip1559\") {\n        const typedTransaction = transaction;\n        ox__TransactionEnvelopeEip1559.assert(typedTransaction);\n        return ox__TransactionEnvelopeEip1559.serialize(typedTransaction, {\n            signature,\n        });\n    }\n    if (type === \"legacy\") {\n        const typedTransaction = transaction;\n        ox__TransactionEnvelopeLegacy.assert(typedTransaction);\n        return ox__TransactionEnvelopeLegacy.serialize(typedTransaction, {\n            signature,\n        });\n    }\n    if (type === \"eip2930\") {\n        const typedTransaction = transaction;\n        ox__TransactionEnvelopeEip2930.assert(typedTransaction);\n        return ox__TransactionEnvelopeEip2930.serialize(typedTransaction, {\n            signature,\n        });\n    }\n    if (type === \"eip7702\") {\n        const typedTransaction = transaction;\n        ox__TransactionEnvelopeEip7702.assert(typedTransaction);\n        return ox__TransactionEnvelopeEip7702.serialize(typedTransaction, {\n            signature,\n        });\n    }\n    throw new Error(\"Invalid transaction type\");\n}\n/**\n * @internal\n */\nfunction getTransactionEnvelopeType(transactionEnvelope) {\n    if (typeof transactionEnvelope.type !== \"undefined\") {\n        return transactionEnvelope.type;\n    }\n    if (typeof transactionEnvelope.authorizationList !== \"undefined\") {\n        return \"eip7702\";\n    }\n    if (typeof transactionEnvelope.maxFeePerGas !== \"undefined\" ||\n        typeof transactionEnvelope.maxPriorityFeePerGas !== \"undefined\") {\n        return \"eip1559\";\n    }\n    if (typeof transactionEnvelope.gasPrice !== \"undefined\") {\n        if (typeof transactionEnvelope.accessList !== \"undefined\") {\n            return \"eip2930\";\n        }\n        return \"legacy\";\n    }\n    throw new Error(\"Invalid transaction type\");\n}\n//# sourceMappingURL=serialize-transaction.js.map","import { getContract } from \"../contract/contract.js\";\nimport { toSerializableTransaction } from \"../transaction/actions/to-serializable-transaction.js\";\nimport { readContract } from \"../transaction/read-contract.js\";\nimport { serializeTransaction } from \"../transaction/serialize-transaction.js\";\nconst OPStackGasPriceOracleAddress = \"0x420000000000000000000000000000000000000F\";\n/**\n * @internal\n */\nexport async function estimateL1Fee(options) {\n    const { transaction, gasPriceOracleAddress } = options;\n    const oracleContract = getContract({\n        address: gasPriceOracleAddress || OPStackGasPriceOracleAddress,\n        chain: transaction.chain,\n        client: transaction.client,\n    });\n    //\n    // biome-ignore lint/correctness/noUnusedVariables: purposefully remove gasPrice from the transaction\n    const { gasPrice, ...serializableTx } = await toSerializableTransaction({\n        transaction,\n    });\n    const serialized = serializeTransaction({\n        transaction: serializableTx,\n    });\n    //serializeTransaction(transaction);\n    return readContract({\n        contract: oracleContract,\n        method: \"function getL1Fee(bytes memory _data) view returns (uint256)\",\n        params: [serialized],\n    });\n}\n//# sourceMappingURL=estimate-l1-fee.js.map"],"names":["toTupleList","accessList","tuple","address","storageKeys","j","Hex.size","InvalidStorageKeySizeError","Address.assert","Errors.BaseError","storageKey","exponents","format","value","decimals","display","negative","integer","fraction","formatGwei","wei","unit","FeeCapTooHighError","feeCap","Value.formatGwei","GasPriceTooHighError","gasPrice","InvalidChainIdError","chainId","TipAboveFeeCapError","maxPriorityFeePerGas","maxFeePerGas","assert","envelope","to","TransactionEnvelope.InvalidChainIdError","TransactionEnvelope.GasPriceTooHighError","serialize","options","gas","data","input","nonce","serialized","Hex.fromNumber","signature","Signature.yParityToV","v","Signature.InvalidVError","Hex.trimLeft","Rlp.fromHex","serializedType","TransactionEnvelope.FeeCapTooHighError","TransactionEnvelope.TipAboveFeeCapError","accessTupleList","AccessList.toTupleList","Signature.extract","Signature.toTuple","Hex.concat","authorizationList","authorization","TransactionEnvelopeEip1559.assert","authorizationTupleList","Authorization.toTupleList","serializeTransaction","transaction","type","getTransactionEnvelopeType","ox__Signature.fromLegacy","ox__Hex.toBigInt","ox__Signature.vToYParity","typedTransaction","ox__TransactionEnvelopeEip1559.assert","ox__TransactionEnvelopeEip1559.serialize","ox__TransactionEnvelopeLegacy.assert","ox__TransactionEnvelopeLegacy.serialize","ox__TransactionEnvelopeEip2930.assert","ox__TransactionEnvelopeEip2930.serialize","ox__TransactionEnvelopeEip7702.assert","ox__TransactionEnvelopeEip7702.serialize","transactionEnvelope","OPStackGasPriceOracleAddress","estimateL1Fee","gasPriceOracleAddress","oracleContract","getContract","serializableTx","toSerializableTransaction","readContract"],"mappings":"2TA4EO,SAASA,EAAYC,EAAY,CACpC,GAAI,CAACA,GAAcA,EAAW,SAAW,EACrC,MAAO,CAAA,EACX,MAAMC,EAAQ,CAAA,EACd,SAAW,CAAE,QAAAC,EAAS,YAAAC,CAAW,IAAMH,EAAY,CAC/C,QAASI,EAAI,EAAGA,EAAID,EAAY,OAAQC,IACpC,GAAIC,EAASF,EAAYC,CAAC,CAAC,IAAM,GAC7B,MAAM,IAAIE,EAA2B,CACjC,WAAYH,EAAYC,CAAC,CAC7C,CAAiB,EACLF,GACAK,EAAeL,EAAS,CAAE,OAAQ,EAAK,CAAE,EAC7CD,EAAM,KAAK,CAACC,EAASC,CAAW,CAAC,CACrC,CACA,OAAOF,CACX,CAEO,MAAMK,UAAmCE,CAAiB,CAC7D,YAAY,CAAE,WAAAC,GAAc,CACxB,MAAM,yBAAyBA,CAAU,wCAAwCJ,EAASI,CAAU,CAAC,SAAS,EAC9G,OAAO,eAAe,KAAM,OAAQ,CAChC,WAAY,GACZ,aAAc,GACd,SAAU,GACV,MAAO,uCACnB,CAAS,CACL,CACJ,CCrGO,MAAMC,EAAY,CACrB,IAAK,EACL,KAAM,EACN,MAAO,GACP,OAAQ,GACR,MAAO,EACX,EAgBO,SAASC,EAAOC,EAAOC,EAAW,EAAG,CACxC,IAAIC,EAAUF,EAAM,SAAQ,EAC5B,MAAMG,EAAWD,EAAQ,WAAW,GAAG,EACnCC,IACAD,EAAUA,EAAQ,MAAM,CAAC,GAC7BA,EAAUA,EAAQ,SAASD,EAAU,GAAG,EACxC,GAAI,CAACG,EAASC,CAAQ,EAAI,CACtBH,EAAQ,MAAM,EAAGA,EAAQ,OAASD,CAAQ,EAC1CC,EAAQ,MAAMA,EAAQ,OAASD,CAAQ,CAC/C,EACI,OAAAI,EAAWA,EAAS,QAAQ,QAAS,EAAE,EAChC,GAAGF,EAAW,IAAM,EAAE,GAAGC,GAAW,GAAG,GAAGC,EAAW,IAAIA,CAAQ,GAAK,EAAE,EACnF,CAkCO,SAASC,EAAWC,EAAKC,EAAO,MAAO,CAC1C,OAAOT,EAAOQ,EAAKT,EAAU,KAAOA,EAAUU,CAAI,CAAC,CACvD,CCxDO,MAAMC,UAA2Bb,CAAiB,CACrD,YAAY,CAAE,OAAAc,CAAM,EAAM,GAAI,CAC1B,MAAM,yDAAyDA,EAAS,MAAMC,EAAiBD,CAAM,CAAC,QAAU,EAAE,8DAA8D,EAChL,OAAO,eAAe,KAAM,OAAQ,CAChC,WAAY,GACZ,aAAc,GACd,SAAU,GACV,MAAO,wCACnB,CAAS,CACL,CACJ,CAeO,MAAME,UAA6BhB,CAAiB,CACvD,YAAY,CAAE,SAAAiB,CAAQ,EAAM,GAAI,CAC5B,MAAM,8BAA8BA,EAAW,MAAMF,EAAiBE,CAAQ,CAAC,QAAU,EAAE,8DAA8D,EACzJ,OAAO,eAAe,KAAM,OAAQ,CAChC,WAAY,GACZ,aAAc,GACd,SAAU,GACV,MAAO,0CACnB,CAAS,CACL,CACJ,CAYO,MAAMC,UAA4BlB,CAAiB,CACtD,YAAY,CAAE,QAAAmB,GAAW,CACrB,MAAM,OAAOA,EAAY,IACnB,aAAaA,CAAO,gBACpB,sBAAsB,EAC5B,OAAO,eAAe,KAAM,OAAQ,CAChC,WAAY,GACZ,aAAc,GACd,SAAU,GACV,MAAO,yCACnB,CAAS,CACL,CACJ,CAgDO,MAAMC,UAA4BpB,CAAiB,CACtD,YAAY,CAAE,qBAAAqB,EAAsB,aAAAC,CAAY,EAAM,CAAA,EAAI,CACtD,MAAM,CACF,6CAA6CD,EACvC,MAAMN,EAAiBM,CAAoB,CAAC,QAC5C,EAAE,wDAAwDC,EAAe,MAAMP,EAAiBO,CAAY,CAAC,QAAU,EAAE,IAC3I,EAAU,KAAK;AAAA,CAAI,CAAC,EACZ,OAAO,eAAe,KAAM,OAAQ,CAChC,WAAY,GACZ,aAAc,GACd,SAAU,GACV,MAAO,yCACnB,CAAS,CACL,CACJ,CC9GO,SAASC,EAAOC,EAAU,CAC7B,KAAM,CAAE,QAAAL,EAAS,SAAAF,EAAU,GAAAQ,CAAE,EAAKD,EAGlC,GAFIC,GACA1B,EAAe0B,EAAI,CAAE,OAAQ,EAAK,CAAE,EACpC,OAAON,EAAY,KAAeA,GAAW,EAC7C,MAAM,IAAIO,EAAwC,CAAE,QAAAP,EAAS,EACjE,GAAIF,GAAY,OAAOA,CAAQ,EAAI,IAAM,KAAO,GAC5C,MAAM,IAAIU,EAAyC,CAAE,SAAAV,EAAU,CACvE,CAySO,SAASW,EAAUJ,EAAUK,EAAU,GAAI,CAC9C,KAAM,CAAE,QAAAV,EAAU,EAAG,IAAAW,EAAK,KAAAC,EAAM,MAAAC,EAAO,MAAAC,EAAO,GAAAR,EAAI,MAAArB,EAAO,SAAAa,CAAQ,EAAKO,EACtED,EAAOC,CAAQ,EACf,IAAIU,EAAa,CACbD,EAAQE,EAAeF,CAAK,EAAI,KAChChB,EAAWkB,EAAelB,CAAQ,EAAI,KACtCa,EAAMK,EAAeL,CAAG,EAAI,KAC5BL,GAAM,KACNrB,EAAQ+B,EAAe/B,CAAK,EAAI,KAChC2B,GAAQC,GAAS,IACzB,EACI,MAAMI,GAAa,IAAM,CACrB,GAAIP,EAAQ,UACR,MAAO,CACH,EAAGA,EAAQ,UAAU,EACrB,EAAGA,EAAQ,UAAU,EACrB,EAAGQ,EAAqBR,EAAQ,UAAU,OAAO,CACjE,EACQ,GAAI,SAAOL,EAAS,EAAM,KAAe,OAAOA,EAAS,EAAM,KAE/D,MAAO,CACH,EAAGA,EAAS,EACZ,EAAGA,EAAS,EACZ,EAAGA,EAAS,CACxB,CACI,GAAC,EACD,GAAIY,EAAW,CACX,MAAME,GAAK,IAAM,CAEb,GAAIF,EAAU,GAAK,GAEf,OADwB,KAAK,OAAOA,EAAU,EAAI,IAAM,CAAC,EACnC,EACXA,EAAU,EACd,IAAMA,EAAU,IAAM,GAAK,EAAI,GAG1C,GAAIjB,EAAU,EACV,OAAOA,EAAU,EAAI,GAAKiB,EAAU,EAAI,GAE5C,MAAME,EAAI,IAAMF,EAAU,IAAM,GAAK,EAAI,GACzC,GAAIA,EAAU,IAAME,EAChB,MAAM,IAAIC,EAAwB,CAAE,MAAOH,EAAU,CAAC,CAAE,EAC5D,OAAOE,CACX,GAAC,EACDJ,EAAa,CACT,GAAGA,EACHC,EAAeG,CAAC,EAChBF,EAAU,IAAM,GAAK,KAAOI,EAAaL,EAAeC,EAAU,CAAC,CAAC,EACpEA,EAAU,IAAM,GAAK,KAAOI,EAAaL,EAAeC,EAAU,CAAC,CAAC,CAChF,CACI,MACSjB,EAAU,IACfe,EAAa,CAAC,GAAGA,EAAYC,EAAehB,CAAO,EAAG,KAAM,IAAI,GACpE,OAAOsB,EAAYP,CAAU,CACjC,CC3XO,MAAMQ,EAAiB,OAsBvB,SAASnB,EAAOC,EAAU,CAC7B,KAAM,CAAE,QAAAL,EAAS,qBAAAE,EAAsB,aAAAC,EAAc,GAAAG,CAAE,EAAKD,EAC5D,GAAIL,GAAW,EACX,MAAM,IAAIO,EAAwC,CAAE,QAAAP,EAAS,EAGjE,GAFIM,GACA1B,EAAe0B,EAAI,CAAE,OAAQ,EAAK,CAAE,EACpCH,GAAgB,OAAOA,CAAY,EAAI,IAAM,KAAO,GACpD,MAAM,IAAIqB,EAAuC,CAAE,OAAQrB,CAAY,CAAE,EAC7E,GAAID,GACAC,GACAD,EAAuBC,EACvB,MAAM,IAAIsB,EAAwC,CAC9C,aAAAtB,EACA,qBAAAD,CACZ,CAAS,CACT,CAgSO,SAASO,EAAUJ,EAAUK,EAAU,GAAI,CAC9C,KAAM,CAAE,QAAAV,EAAS,IAAAW,EAAK,MAAAG,EAAO,GAAAR,EAAI,MAAArB,EAAO,aAAAkB,EAAc,qBAAAD,EAAsB,WAAA7B,EAAY,KAAAuC,EAAM,MAAAC,CAAK,EAAMR,EACzGD,EAAOC,CAAQ,EACf,MAAMqB,EAAkBC,EAAuBtD,CAAU,EACnD4C,EAAYW,EAAkBlB,EAAQ,WAAaL,CAAQ,EAC3DU,EAAa,CACfC,EAAehB,CAAO,EACtBc,EAAQE,EAAeF,CAAK,EAAI,KAChCZ,EAAuBc,EAAed,CAAoB,EAAI,KAC9DC,EAAea,EAAeb,CAAY,EAAI,KAC9CQ,EAAMK,EAAeL,CAAG,EAAI,KAC5BL,GAAM,KACNrB,EAAQ+B,EAAe/B,CAAK,EAAI,KAChC2B,GAAQC,GAAS,KACjBa,EACA,GAAIT,EAAYY,EAAkBZ,CAAS,EAAI,CAAA,CACvD,EACI,OAAOa,EAAWP,EAAgBD,EAAYP,CAAU,CAAC,CAC7D,CCjUO,SAASX,EAAOC,EAAU,CAC7B,KAAM,CAAE,QAAAL,EAAS,SAAAF,EAAU,GAAAQ,CAAE,EAAKD,EAClC,GAAIL,GAAW,EACX,MAAM,IAAIO,EAAwC,CAAE,QAAAP,EAAS,EAGjE,GAFIM,GACA1B,EAAe0B,EAAI,CAAE,OAAQ,EAAK,CAAE,EACpCR,GAAY,OAAOA,CAAQ,EAAI,IAAM,KAAO,GAC5C,MAAM,IAAIU,EAAyC,CAAE,SAAAV,EAAU,CACvE,CA2RO,SAASW,EAAUJ,EAAUK,EAAU,GAAI,CAC9C,KAAM,CAAE,QAAAV,EAAS,IAAAW,EAAK,KAAAC,EAAM,MAAAC,EAAO,MAAAC,EAAO,GAAAR,EAAI,MAAArB,EAAO,WAAAZ,EAAY,SAAAyB,CAAQ,EAAKO,EAC9ED,EAAOC,CAAQ,EACf,MAAMqB,EAAkBC,EAAuBtD,CAAU,EACnD4C,EAAYW,EAAkBlB,EAAQ,WAAaL,CAAQ,EAC3DU,EAAa,CACfC,EAAehB,CAAO,EACtBc,EAAQE,EAAeF,CAAK,EAAI,KAChChB,EAAWkB,EAAelB,CAAQ,EAAI,KACtCa,EAAMK,EAAeL,CAAG,EAAI,KAC5BL,GAAM,KACNrB,EAAQ+B,EAAe/B,CAAK,EAAI,KAChC2B,GAAQC,GAAS,KACjBa,EACA,GAAIT,EAAYY,EAAkBZ,CAAS,EAAI,CAAA,CACvD,EACI,OAAOa,EAAW,OAAQR,EAAYP,CAAU,CAAC,CACrD,CCxUO,MAAMQ,EAAiB,OAuBvB,SAASnB,EAAOC,EAAU,CAC7B,KAAM,CAAE,kBAAA0B,CAAiB,EAAK1B,EAC9B,GAAI0B,EACA,UAAWC,KAAiBD,EAAmB,CAC3C,KAAM,CAAE,QAAAxD,EAAS,QAAAyB,CAAO,EAAKgC,EAG7B,GAFIzD,GACAK,EAAeL,EAAS,CAAE,OAAQ,EAAK,CAAE,EACzC,OAAOyB,CAAO,EAAI,EAClB,MAAM,IAAIO,EAAwC,CAAE,QAAAP,EAAS,CACrE,CAEJiC,EAAkC5B,CAAQ,CAC9C,CAuUO,SAASI,EAAUJ,EAAUK,EAAU,GAAI,CAC9C,KAAM,CAAE,kBAAAqB,EAAmB,QAAA/B,EAAS,IAAAW,EAAK,MAAAG,EAAO,GAAAR,EAAI,MAAArB,EAAO,aAAAkB,EAAc,qBAAAD,EAAsB,WAAA7B,EAAY,KAAAuC,EAAM,MAAAC,CAAK,EAAMR,EAC5HD,EAAOC,CAAQ,EACf,MAAMqB,EAAkBC,EAAuBtD,CAAU,EACnD6D,EAAyBC,EAA0BJ,CAAiB,EACpEd,EAAYW,EAAkBlB,EAAQ,WAAaL,CAAQ,EAC3DU,EAAa,CACfC,EAAehB,CAAO,EACtBc,EAAQE,EAAeF,CAAK,EAAI,KAChCZ,EAAuBc,EAAed,CAAoB,EAAI,KAC9DC,EAAea,EAAeb,CAAY,EAAI,KAC9CQ,EAAMK,EAAeL,CAAG,EAAI,KAC5BL,GAAM,KACNrB,EAAQ+B,EAAe/B,CAAK,EAAI,KAChC2B,GAAQC,GAAS,KACjBa,EACAQ,EACA,GAAIjB,EAAYY,EAAkBZ,CAAS,EAAI,CAAA,CACvD,EACI,OAAOa,EAAWP,EAAgBD,EAAYP,CAAU,CAAC,CAC7D,CC7WO,SAASqB,GAAqB1B,EAAS,CAC1C,KAAM,CAAE,YAAA2B,CAAW,EAAK3B,EAClB4B,EAAOC,GAA2BF,CAAW,EAE7CpB,GAAa,IAAM,CACrB,GAAIP,EAAQ,UACR,MAAI,MAAOA,EAAQ,WACf,OAAOA,EAAQ,UAAU,EAAM,IACxB8B,EAAyB,CAC5B,EAAGC,EAAiB/B,EAAQ,UAAU,CAAC,EACvC,EAAG+B,EAAiB/B,EAAQ,UAAU,CAAC,EACvC,EAAG,OAAOA,EAAQ,UAAU,CAAC,CACjD,CAAiB,EAEE,CACH,EAAG+B,EAAiB/B,EAAQ,UAAU,CAAC,EACvC,EAAG+B,EAAiB/B,EAAQ,UAAU,CAAC,EAEvC,QAASA,EAAQ,UACZ,OACrB,EAEQ,GAAI,SAAO2B,EAAY,EAAM,KACzB,OAAOA,EAAY,QAAY,KAGnC,IAAIA,EAAY,IAAM,QAAaA,EAAY,IAAM,OACjD,MAAM,IAAI,MAAM,6CAA6C,EAEjE,MAAO,CACH,EAAG,OAAOA,EAAY,GAAM,SACtBA,EAAY,EACZI,EAAiBJ,EAAY,CAAC,EACpC,EAAG,OAAOA,EAAY,GAAM,SACtBA,EAAY,EACZI,EAAiBJ,EAAY,CAAC,EACpC,QAAS,OAAOA,EAAY,EAAM,KAC9B,OAAOA,EAAY,QAAY,IAC7BK,EAAyB,OAAOL,EAAY,CAAC,CAAC,EAC9C,OAAOA,EAAY,OAAO,CAC5C,EACI,GAAC,EACD,GAAIC,IAAS,UAAW,CACpB,MAAMK,EAAmBN,EACzBO,OAAAA,EAAsCD,CAAgB,EAC/CE,EAAyCF,EAAkB,CAC9D,UAAA1B,CACZ,CAAS,CACL,CACA,GAAIqB,IAAS,SAAU,CACnB,MAAMK,EAAmBN,EACzBS,OAAAA,EAAqCH,CAAgB,EAC9CI,EAAwCJ,EAAkB,CAC7D,UAAA1B,CACZ,CAAS,CACL,CACA,GAAIqB,IAAS,UAAW,CACpB,MAAMK,EAAmBN,EACzBW,OAAAA,EAAsCL,CAAgB,EAC/CM,EAAyCN,EAAkB,CAC9D,UAAA1B,CACZ,CAAS,CACL,CACA,GAAIqB,IAAS,UAAW,CACpB,MAAMK,EAAmBN,EACzBa,OAAAA,EAAsCP,CAAgB,EAC/CQ,EAAyCR,EAAkB,CAC9D,UAAA1B,CACZ,CAAS,CACL,CACA,MAAM,IAAI,MAAM,0BAA0B,CAC9C,CAIA,SAASsB,GAA2Ba,EAAqB,CACrD,GAAI,OAAOA,EAAoB,KAAS,IACpC,OAAOA,EAAoB,KAE/B,GAAI,OAAOA,EAAoB,kBAAsB,IACjD,MAAO,UAEX,GAAI,OAAOA,EAAoB,aAAiB,KAC5C,OAAOA,EAAoB,qBAAyB,IACpD,MAAO,UAEX,GAAI,OAAOA,EAAoB,SAAa,IACxC,OAAI,OAAOA,EAAoB,WAAe,IACnC,UAEJ,SAEX,MAAM,IAAI,MAAM,0BAA0B,CAC9C,CCnHA,MAAMC,GAA+B,6CAI9B,eAAeC,GAAc5C,EAAS,CACzC,KAAM,CAAE,YAAA2B,EAAa,sBAAAkB,CAAqB,EAAK7C,EACzC8C,EAAiBC,EAAY,CAC/B,QAASF,GAAyBF,GAClC,MAAOhB,EAAY,MACnB,OAAQA,EAAY,MAC5B,CAAK,EAGK,CAAE,SAAAvC,EAAU,GAAG4D,CAAc,EAAK,MAAMC,EAA0B,CACpE,YAAAtB,CACR,CAAK,EACKtB,EAAaqB,GAAqB,CACpC,YAAasB,CACrB,CAAK,EAED,OAAOE,EAAa,CAChB,SAAUJ,EACV,OAAQ,+DACR,OAAQ,CAACzC,CAAU,CAC3B,CAAK,CACL","x_google_ignoreList":[0,1,2,3,4,5,6,7,8]}