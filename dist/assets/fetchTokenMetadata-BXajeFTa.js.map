{"version":3,"mappings":";uDACA,MAAMA,EAAe,+BAWd,SAASC,EAAaC,EAAO,CAChC,MAAI,EAAAA,EAAM,YAAW,EAAG,WAAWF,CAAY,CAInD,CAWO,SAASG,EAAkBD,EAAO,CACrC,MAAME,EAAaF,EAAM,QAAQ,GAAG,EAC9BG,EAASH,EAAM,MAAME,EAAa,CAAC,EACzC,OAAOE,EAAeD,CAAM,CAChC,CChCA,MAAME,EAAa,8BAWZ,SAASC,EAAiBN,EAAO,CACpC,MAAI,EAAAA,EAAM,YAAW,EAAG,WAAWK,CAAU,CAIjD,CAWO,SAASE,EAAgBP,EAAO,CACnC,MAAME,EAAaF,EAAM,QAAQ,GAAG,EAC9BQ,EAAOR,EAAM,MAAME,EAAa,CAAC,EACvC,GAAI,CAEA,OAAO,mBAAmBM,CAAI,CAClC,MACM,CACF,OAAOA,CACX,CACJ,CC3BO,eAAeC,EAAmBC,EAAS,CAC9C,KAAM,CAAE,OAAAC,EAAQ,QAAAC,EAAS,SAAAC,CAAQ,EAAKH,EAEtC,GAAIX,EAAac,CAAQ,EACrB,GAAI,CACA,OAAO,KAAK,MAAMZ,EAAkBY,CAAQ,CAAC,CACjD,OACOC,EAAG,CACN,cAAQ,MAAM,qCAAsC,CAAE,QAAAF,EAAS,SAAAC,CAAQ,EAAIC,CAAC,EACtEA,CACV,CAEJ,GAAIR,EAAiBO,CAAQ,EACzB,GAAI,CACA,OAAO,KAAK,MAAMN,EAAgBM,CAAQ,CAAC,CAC/C,OACOC,EAAG,CACN,cAAQ,MAAM,mCAAoC,CAAE,QAAAF,EAAS,SAAAC,CAAQ,EAAIC,CAAC,EACpEA,CACV,CAGJ,KAAM,CAAE,SAAAC,CAAQ,EAAK,MAAKC,EAAA,yBAAAD,CAAA,OAAC,QAAO,qBAA2B,OAAAE,KAAA,wDAE7D,GAAI,CACA,GAAI,CAACJ,EAAS,SAAS,MAAM,EACzB,OAAO,MAAO,MAAME,EAAS,CAAE,OAAAJ,EAAQ,IAAKE,CAAQ,CAAE,GAAG,KAAI,CAErE,OACOC,EAAG,CACN,cAAQ,MAAM,kCAAmC,CAAE,QAAAF,EAAS,SAAAC,CAAQ,EAAIC,CAAC,EACnEA,CACV,CAEA,GAAI,CACA,GAAI,CAEA,OAAO,MAAO,MAAMC,EAAS,CACzB,OAAAJ,EACA,IAAKE,EAAS,QAAQ,OAAQK,EAAYN,EAAS,CAAE,KAAM,EAAE,CAAE,EAAE,MAAM,CAAC,CAAC,CACzF,CAAa,GAAG,KAAI,CACZ,MACM,CAEF,OAAO,MAAO,MAAMG,EAAS,CACzB,OAAAJ,EACA,IAAKE,EAAS,QAAQ,OAAQD,EAAQ,SAAQ,CAAE,CAChE,CAAa,GAAG,KAAI,CACZ,CACJ,OACOE,EAAG,CACN,cAAQ,MAAM,8BAA+B,CAAE,QAAAF,EAAS,SAAAC,CAAQ,EAAIC,CAAC,EAC/DA,CACV,CACJ","names":["Base64Prefix","isBase64JSON","input","parseBase64String","commaIndex","base64","base64ToString","UTF8Prefix","isUTF8JSONString","parseUTF8String","utf8","fetchTokenMetadata","options","client","tokenId","tokenUri","e","download","__vitePreload","n","numberToHex"],"ignoreList":[0,1,2],"sources":["../../node_modules/thirdweb/dist/esm/utils/base64/base64.js","../../node_modules/thirdweb/dist/esm/utils/utf8/utf8.js","../../node_modules/thirdweb/dist/esm/utils/nft/fetchTokenMetadata.js"],"sourcesContent":["import { base64ToString } from \"../uint8-array.js\";\nconst Base64Prefix = \"data:application/json;base64\";\n/**\n * Checks if a given string is a base64 encoded JSON string.\n * @param input - The string to be checked.\n * @returns True if the input string starts with \"data:application/json;base64\", false otherwise.\n * @example\n * ```ts\n * isBase64JSON(\"data:application/json;base64,eyJ0ZXN0IjoiYmFzZTY0In0=\")\n * // true\n * ```\n */\nexport function isBase64JSON(input) {\n    if (input.toLowerCase().startsWith(Base64Prefix)) {\n        return true;\n    }\n    return false;\n}\n/**\n * Parses a base64 string and returns the decoded string.\n * @param input - The base64 string to parse.\n * @returns The decoded string.\n * @example\n * ```ts\n * parseBase64String(\"data:application/json;base64,eyJ0ZXN0IjoiYmFzZTY0In0=\")\n * // '{\"test\":\"base64\"}'\n * ```\n */\nexport function parseBase64String(input) {\n    const commaIndex = input.indexOf(\",\");\n    const base64 = input.slice(commaIndex + 1);\n    return base64ToString(base64);\n}\n//# sourceMappingURL=base64.js.map","const UTF8Prefix = \"data:application/json;utf-8\";\n/**\n * Checks if a given string is a UTF-8 encoded JSON string.\n * @param input - The string to be checked.\n * @returns True if the input string starts with \"data:application/json;utf-8\", false otherwise.\n * @example\n * ```ts\n * isUTF8JSONString(\"data:application/json;utf-8,{ \\\"test\\\": \\\"utf8\\\" }\")\n * // true\n * ```\n */\nexport function isUTF8JSONString(input) {\n    if (input.toLowerCase().startsWith(UTF8Prefix)) {\n        return true;\n    }\n    return false;\n}\n/**\n * Parses a UTF-8 string and returns the decoded string.\n * @param input - The UTF-8 string to parse.\n * @returns The decoded string.\n * @example\n * ```ts\n * parseUTF8String(\"data:application/json;utf-8,{ \\\"test\\\": \\\"utf8\\\" }\")\n * // '{\"test\":\"utf8\"}'\n * ```\n */\nexport function parseUTF8String(input) {\n    const commaIndex = input.indexOf(\",\");\n    const utf8 = input.slice(commaIndex + 1);\n    try {\n        // try to decode the UTF-8 string, if it fails, return the original string\n        return decodeURIComponent(utf8);\n    }\n    catch {\n        return utf8;\n    }\n}\n//# sourceMappingURL=utf8.js.map","import { isBase64JSON, parseBase64String } from \"../base64/base64.js\";\nimport { numberToHex } from \"../encoding/hex.js\";\nimport { isUTF8JSONString, parseUTF8String } from \"../utf8/utf8.js\";\n/**\n * Fetches the metadata for a token.\n *\n * @param options - The options for fetching the token metadata.\n * @returns The token metadata.\n * @internal\n */\nexport async function fetchTokenMetadata(options) {\n    const { client, tokenId, tokenUri } = options;\n    // handle case where the URI is a base64 encoded JSON (onchain nft)\n    if (isBase64JSON(tokenUri)) {\n        try {\n            return JSON.parse(parseBase64String(tokenUri));\n        }\n        catch (e) {\n            console.error(\"Failed to fetch base64 encoded NFT\", { tokenId, tokenUri }, e);\n            throw e;\n        }\n    }\n    if (isUTF8JSONString(tokenUri)) {\n        try {\n            return JSON.parse(parseUTF8String(tokenUri));\n        }\n        catch (e) {\n            console.error(\"Failed to fetch utf8 encoded NFT\", { tokenId, tokenUri }, e);\n            throw e;\n        }\n    }\n    // in all other cases we will need the `download` function from storage\n    const { download } = await import(\"../../storage/download.js\");\n    // handle non-dynamic uris (most common case -> skip the other checks)\n    try {\n        if (!tokenUri.includes(\"{id}\")) {\n            return await (await download({ client, uri: tokenUri })).json();\n        }\n    }\n    catch (e) {\n        console.error(\"Failed to fetch non-dynamic NFT\", { tokenId, tokenUri }, e);\n        throw e;\n    }\n    // DYNAMIC NFT FORMATS (2 options, sadly has to be waterfall)\n    try {\n        try {\n            // try first dynamic id format\n            return await (await download({\n                client,\n                uri: tokenUri.replace(\"{id}\", numberToHex(tokenId, { size: 32 }).slice(2)),\n            })).json();\n        }\n        catch {\n            // otherwise attempt the second format\n            return await (await download({\n                client,\n                uri: tokenUri.replace(\"{id}\", tokenId.toString()),\n            })).json();\n        }\n    }\n    catch (e) {\n        console.error(\"Failed to fetch dynamic NFT\", { tokenId, tokenUri }, e);\n        throw e;\n    }\n}\n//# sourceMappingURL=fetchTokenMetadata.js.map"],"file":"assets/fetchTokenMetadata-BXajeFTa.js"}