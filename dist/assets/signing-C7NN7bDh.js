import{w as u,r as v,b1 as f,b2 as x,O as c,b3 as g,b4 as D,b5 as M,b6 as I,b7 as C,aL as m,b8 as h,E as l}from"./index-BQlDc_X7.js";import{concatHex as V}from"./concat-hex-C0E3ZByY.js";import{p as w}from"./index-C180y6Cd.js";import"./framer-motion-BLeoVWJg.js";import"./react-vendor-hc9cV1gX.js";import"./d3-vendor-DXMZTTbz.js";import"./supabase-vendor-CzrfDcjy.js";import"./send-eip712-transaction-CWcqorAD.js";import"./eth_sendRawTransaction-DPdnXbFR.js";import"./sha256-CWpujDzl.js";const P="0x6492649264926492649264926492649264926492649264926492649264926492";function A({address:t,data:r,signature:e}){return V([u([{type:"address"},{type:"bytes"},{type:"bytes"}],[t,r,e]),P])}const _="0x1626ba7e",H=[{name:"hash",type:"bytes32"},{name:"signature",type:"bytes"}],O=[{type:"bytes4"}];async function $(t){return v({contract:t.contract,method:[_,H,O],params:[t.hash,t.signature]})}const F="0x1626ba7e";async function b({hash:t,signature:r,contract:e}){try{return await $({contract:e,hash:t,signature:r})===F}catch(n){return console.error("Error verifying EIP-1271 signature",n),!1}}const L=`Ethereum Signed Message:
`;function U(t,r){const e=typeof t=="string"?f(t):t.raw instanceof Uint8Array?t.raw:x(t.raw),n=f(`${L}${e.length}`);return c(g(n,e),r)}function B(t){const{domain:r={},message:e,primaryType:n}=t,a={EIP712Domain:D(r),...t.types};M({domain:r,message:e,primaryType:n,types:a});const s=["0x1901"];if(r&&s.push(I({domain:r,types:a})),n!=="EIP712Domain"){const i=(()=>{const o=T({data:e,primaryType:n,types:a});return c(o)})();s.push(i)}return c(g(...s.map(i=>C(i))))}function T({data:t,primaryType:r,types:e}){const n=[{type:"bytes32"}],a=[N({primaryType:r,types:e})];if(!e[r])throw new Error("Invalid types");for(const s of e[r]){const[i,o]=S({name:s.name,type:s.type,types:e,value:t[s.name]});n.push(i),a.push(o)}return u(n,a)}function N({primaryType:t,types:r}){const e=m(k({primaryType:t,types:r}));return c(e)}function k({primaryType:t,types:r}){let e="";const n=E({primaryType:t,types:r});n.delete(t);const a=[t,...Array.from(n).sort()];for(const s of a){if(!r[s])throw new Error("Invalid types");e+=`${s}(${r[s].map(({name:i,type:o})=>`${o} ${i}`).join(",")})`}return e}function E({primaryType:t,types:r},e=new Set){const a=t.match(/^\w*/u)?.[0];if(e.has(a)||r[a]===void 0)return e;e.add(a);for(const s of r[a])E({primaryType:s.type,types:r},e);return e}function S({types:t,name:r,type:e,value:n}){if(t[e]!==void 0)return[{type:"bytes32"},c(T({data:n,primaryType:e,types:t}))];if(e==="bytes")return n=`0x${(n.length%2?"0":"")+n.slice(2)}`,[{type:"bytes32"},c(n)];if(e==="string")return[{type:"bytes32"},c(m(n))];if(e.lastIndexOf("]")===e.length-1){const a=e.slice(0,e.lastIndexOf("[")),s=n.map(i=>S({name:r,type:a,types:t,value:i}));return[{type:"bytes32"},c(u(s.map(([i])=>i),s.map(([,i])=>i)))]}return[{type:e},n]}async function Z({accountContract:t,factoryContract:r,options:e,message:n}){const a=U(n);let s;const i=u([{type:"bytes32"}],[a]);if(s=await e.personalAccount.signTypedData({domain:{chainId:e.chain.id,name:"Account",verifyingContract:t.address,version:"1"},message:{message:i},primaryType:"AccountMessage",types:{AccountMessage:[{name:"message",type:"bytes"}]}}),await h(t)){if(await b({contract:t,hash:a,signature:s}))return s;throw new Error("Failed to verify signature")}else{const p=w({accountSalt:e.overrides?.accountSalt,adminAddress:e.personalAccount.address,createAccountOverride:e.overrides?.createAccount,factoryContract:r});if(!p)throw new Error("Create account override not provided");const d=await l(p);return A({address:r.address,data:d,signature:s})}}async function ee({accountContract:t,factoryContract:r,options:e,typedData:n}){if(n.domain?.verifyingContract?.toLowerCase()===t.address?.toLowerCase())return e.personalAccount.signTypedData(n);const s=B(n);let i;const o=u([{type:"bytes32"}],[s]);if(i=await e.personalAccount.signTypedData({domain:{chainId:e.chain.id,name:"Account",verifyingContract:t.address,version:"1"},message:{message:o},primaryType:"AccountMessage",types:{AccountMessage:[{name:"message",type:"bytes"}]}}),await h(t)){if(await b({contract:t,hash:s,signature:i}))return i;throw new Error("Failed to verify signature")}else{const d=w({accountSalt:e.overrides?.accountSalt,adminAddress:e.personalAccount.address,createAccountOverride:e.overrides?.createAccount,factoryContract:r});if(!d)throw new Error("Create account override not provided");const y=await l(d);return A({address:r.address,data:y,signature:i})}}export{Z as smartAccountSignMessage,ee as smartAccountSignTypedData};
//# sourceMappingURL=signing-C7NN7bDh.js.map
