{"version":3,"mappings":"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","names":["cachedProvider","storageKeys","connectWC","options","emitter","walletId","storage","sessionHandler","provider","initProvider","wcOptions","onDisplayUri","walletInfo","getWalletInfo","uri","appUrl","fullUrl","formatWalletConnectUrl","optionalChains","chainToRequest","chainsToRequestForSafe","getCachedChain","chainsToRequest","rpcMap","getChainsToRequest","NAMESPACE","setRequestedChainsIds","x","currentChainId","providerChainId","normalizeChainId","address","firstAccountOn","chain","savedParams","saveConnectParamsToStorage","onConnect","ensureTargetChain","TARGET_CAIP","TARGET_HEX","numberToHex","hasChainEnabled","requestAndOpenWallet","err","routeChain","anyRoutableChain","getNS","session","caip","ns","hit","a","autoConnectWC","savedConnectParams","getSavedConnectParamsFromStorage","sessionRequestHandler","UniversalProvider","getDefaultAppMetadata","DEFAULT_PROJECT_ID","handleSessionRequest","walletLinkToOpen","createAccount","client","getAddress","tx","transactionHash","trackTransaction","message","messageToSign","stringToHex","uint8ArrayToHex","_data","data","parseTypedData","domain","primaryType","types","getTypesForEIP712Domain","validateTypedData","typedData","serializeTypedData","args","payload","resultPromise","account","disconnect","onAccountsChanged","onChainChanged","onDisconnect","accounts","newAccount","newChainId","newChain","switchChainWC","error","UserRejectedRequestError","SwitchChainError","chains","stringify","chainIds","getRpcUrlForChain"],"ignoreList":[0],"sources":["../../node_modules/thirdweb/dist/esm/wallets/wallet-connect/controller.js"],"sourcesContent":["import { getTypesForEIP712Domain, SwitchChainError, serializeTypedData, UserRejectedRequestError, validateTypedData, } from \"viem\";\nimport { trackTransaction } from \"../../analytics/track/transaction.js\";\nimport { getCachedChain, getRpcUrlForChain } from \"../../chains/utils.js\";\nimport { getAddress } from \"../../utils/address.js\";\nimport { numberToHex, stringToHex, uint8ArrayToHex, } from \"../../utils/encoding/hex.js\";\nimport { stringify } from \"../../utils/json.js\";\nimport { parseTypedData } from \"../../utils/signatures/helpers/parse-typed-data.js\";\nimport { getSavedConnectParamsFromStorage, saveConnectParamsToStorage, } from \"../../utils/storage/walletStorage.js\";\nimport { formatWalletConnectUrl } from \"../../utils/url.js\";\nimport { getWalletInfo } from \"../__generated__/getWalletInfo.js\";\nimport { getDefaultAppMetadata } from \"../utils/defaultDappMetadata.js\";\nimport { normalizeChainId } from \"../utils/normalizeChainId.js\";\nimport { DEFAULT_PROJECT_ID, NAMESPACE } from \"./constants.js\";\nlet cachedProvider = null;\nconst storageKeys = {\n    lastUsedChainId: \"tw.wc.lastUsedChainId\",\n    requestedChains: \"tw.wc.requestedChains\",\n};\n/**\n * Checks if the provided wallet is a Wallet Connect wallet.\n *\n * @param wallet - The wallet to check.\n * @returns True if the wallet is a Wallet Connect wallet, false otherwise.\n */\nexport function isWalletConnect(wallet) {\n    return wallet.id === \"walletConnect\";\n}\n/**\n * @internal\n */\nexport async function connectWC(options, emitter, walletId, storage, sessionHandler) {\n    const provider = await initProvider(options, walletId, sessionHandler);\n    const wcOptions = options.walletConnect;\n    let { onDisplayUri } = wcOptions || {};\n    const walletInfo = await getWalletInfo(walletId);\n    // use default sessionHandler unless onDisplayUri is explicitly provided\n    if (!onDisplayUri && sessionHandler) {\n        const deeplinkHandler = (uri) => {\n            const appUrl = walletInfo.mobile.native || walletInfo.mobile.universal;\n            if (!appUrl) {\n                // generic wc uri\n                sessionHandler(uri);\n                return;\n            }\n            const fullUrl = formatWalletConnectUrl(appUrl, uri).redirect;\n            sessionHandler(fullUrl);\n        };\n        onDisplayUri = deeplinkHandler;\n    }\n    if (onDisplayUri) {\n        provider.events.addListener(\"display_uri\", onDisplayUri);\n    }\n    let optionalChains = wcOptions?.optionalChains;\n    let chainToRequest = options.chain;\n    // ignore the given options chains - and set the safe supported chains\n    if (walletId === \"global.safe\") {\n        optionalChains = chainsToRequestForSafe.map(getCachedChain);\n        if (chainToRequest && !optionalChains.includes(chainToRequest)) {\n            chainToRequest = undefined;\n        }\n    }\n    // For UniversalProvider, we still need chain configuration for session management\n    const { chains: chainsToRequest, rpcMap } = getChainsToRequest({\n        chain: chainToRequest,\n        client: options.client,\n        optionalChains: optionalChains,\n    });\n    // For UniversalProvider, we need to connect with namespaces\n    await provider.connect({\n        ...(wcOptions?.pairingTopic\n            ? { pairingTopic: wcOptions?.pairingTopic }\n            : {}),\n        optionalNamespaces: {\n            [NAMESPACE]: {\n                chains: chainsToRequest,\n                events: [\"chainChanged\", \"accountsChanged\"],\n                methods: [\n                    \"eth_sendTransaction\",\n                    \"eth_signTransaction\",\n                    \"eth_sign\",\n                    \"personal_sign\",\n                    \"eth_signTypedData\",\n                    \"eth_signTypedData_v4\",\n                    \"wallet_switchEthereumChain\",\n                    \"wallet_addEthereumChain\",\n                ],\n                rpcMap,\n            },\n        },\n    });\n    setRequestedChainsIds(chainsToRequest.map((x) => Number(x.split(\":\")[1])), storage);\n    const currentChainId = chainsToRequest[0]?.split(\":\")[1] || 1;\n    const providerChainId = normalizeChainId(currentChainId);\n    const account = firstAccountOn(provider.session, `eip155:1`); // grab the address from mainnet if available\n    const address = account;\n    if (!address) {\n        throw new Error(\"No accounts found on provider.\");\n    }\n    const chain = options.chain && options.chain.id === providerChainId\n        ? options.chain\n        : getCachedChain(providerChainId);\n    if (options) {\n        const savedParams = {\n            chain: options.chain,\n            optionalChains: options.walletConnect?.optionalChains,\n            pairingTopic: options.walletConnect?.pairingTopic,\n        };\n        if (storage) {\n            saveConnectParamsToStorage(storage, walletId, savedParams);\n        }\n    }\n    if (onDisplayUri) {\n        provider.events.removeListener(\"display_uri\", onDisplayUri);\n    }\n    return onConnect(address, chain, provider, emitter, storage, options.client, walletInfo, sessionHandler);\n}\nasync function ensureTargetChain(provider, chain, walletInfo) {\n    if (!provider.session) {\n        throw new Error(\"No session found on provider.\");\n    }\n    const TARGET_CAIP = `eip155:${chain.id}`;\n    const TARGET_HEX = numberToHex(chain.id);\n    // Fast path: already enabled\n    if (hasChainEnabled(provider.session, TARGET_CAIP)) {\n        provider.setDefaultChain(TARGET_CAIP);\n        return;\n    }\n    // 1) Try switch\n    try {\n        await requestAndOpenWallet({\n            provider,\n            payload: {\n                method: \"wallet_switchEthereumChain\",\n                params: [{ chainId: TARGET_HEX }],\n            },\n            chain: TARGET_CAIP, // route to target\n            walletInfo,\n        });\n        provider.setDefaultChain(TARGET_CAIP);\n        return;\n    }\n    catch (err) {\n        const code = err?.code ?? err?.data?.originalError?.code;\n        // 4001 user rejected; stop\n        if (code === 4001)\n            throw new Error(\"User rejected chain switch\");\n        // fall through on 4902 or unknown -> try add\n    }\n    // 2) Add the chain via any chain we already have\n    const routeChain = anyRoutableChain(provider.session);\n    if (!routeChain)\n        throw new Error(\"No routable chain to send wallet_addEthereumChain\");\n    try {\n        await requestAndOpenWallet({\n            provider,\n            payload: {\n                method: \"wallet_addEthereumChain\",\n                params: [\n                    {\n                        chainId: TARGET_HEX,\n                        chainName: chain.name,\n                        nativeCurrency: chain.nativeCurrency,\n                        rpcUrls: [chain.rpc],\n                        blockExplorerUrls: [chain.blockExplorers?.[0]?.url ?? \"\"],\n                    },\n                ],\n            },\n            chain: routeChain, // route via known-good chain, not the target\n            walletInfo,\n        });\n    }\n    catch (err) {\n        const code = err?.code ?? err?.data?.originalError?.code;\n        if (code === 4001)\n            throw new Error(\"User rejected add chain\");\n        throw new Error(`Add chain failed: ${err?.message || String(err)}`);\n    }\n    // 3) Re-try switch after add\n    await requestAndOpenWallet({\n        provider,\n        payload: {\n            method: \"wallet_switchEthereumChain\",\n            params: [{ chainId: TARGET_HEX }],\n        },\n        chain: TARGET_CAIP,\n        walletInfo,\n    });\n    provider.setDefaultChain(TARGET_CAIP);\n    // 4) Verify enablement\n    if (!hasChainEnabled(provider.session, TARGET_CAIP)) {\n        throw new Error(\"Target chain still not enabled by wallet\");\n    }\n}\nfunction getNS(session) {\n    return session?.namespaces?.eip155;\n}\nfunction hasChainEnabled(session, caip) {\n    const ns = getNS(session);\n    return !!ns?.accounts?.some((a) => a.startsWith(`${caip}:`));\n}\nfunction firstAccountOn(session, caip) {\n    const ns = getNS(session);\n    const hit = ns?.accounts?.find((a) => a.startsWith(`${caip}:`)) || ns?.accounts[0];\n    return hit ? (hit.split(\":\")[2] ?? null) : null;\n}\nfunction anyRoutableChain(session) {\n    const ns = getNS(session);\n    return ns?.accounts?.[0]?.split(\":\")?.slice(0, 2)?.join(\":\") ?? null; // e.g. \"eip155:1\"\n}\n/**\n * Auto connect to already connected wallet connect session.\n * @internal\n */\nexport async function autoConnectWC(options, emitter, walletId, storage, sessionHandler) {\n    const savedConnectParams = storage\n        ? await getSavedConnectParamsFromStorage(storage, walletId)\n        : null;\n    const walletInfo = await getWalletInfo(walletId);\n    const provider = await initProvider(savedConnectParams\n        ? {\n            chain: savedConnectParams.chain,\n            client: options.client,\n            walletConnect: {\n                optionalChains: savedConnectParams.optionalChains,\n                pairingTopic: savedConnectParams.pairingTopic,\n            },\n        }\n        : {\n            client: options.client,\n            walletConnect: {},\n        }, walletId, sessionHandler);\n    if (!provider.session) {\n        await provider.disconnect();\n        throw new Error(\"No wallet connect session found on provider.\");\n    }\n    // For UniversalProvider, get accounts from enable() method\n    const namespaceAccounts = provider.session?.namespaces?.[NAMESPACE]?.accounts;\n    const address = namespaceAccounts?.[0]?.split(\":\")[2];\n    if (!address) {\n        throw new Error(\"No accounts found on provider.\");\n    }\n    // For UniversalProvider, get chainId from the session namespaces or use default\n    const currentChainId = options.chain?.id || 1;\n    const providerChainId = normalizeChainId(currentChainId);\n    const chain = options.chain && options.chain.id === providerChainId\n        ? options.chain\n        : getCachedChain(providerChainId);\n    return onConnect(address, chain, provider, emitter, storage, options.client, walletInfo, sessionHandler);\n}\n// Connection utils -----------------------------------------------------------------------------------------------\nasync function initProvider(options, walletId, sessionRequestHandler) {\n    if (cachedProvider) {\n        return cachedProvider;\n    }\n    const walletInfo = await getWalletInfo(walletId);\n    const wcOptions = options.walletConnect;\n    const { UniversalProvider } = await import(\"@walletconnect/universal-provider\");\n    let optionalChains = wcOptions?.optionalChains;\n    let chainToRequest = options.chain;\n    // ignore the given options chains - and set the safe supported chains\n    if (walletId === \"global.safe\") {\n        optionalChains = chainsToRequestForSafe.map(getCachedChain);\n        if (chainToRequest && !optionalChains.includes(chainToRequest)) {\n            chainToRequest = undefined;\n        }\n    }\n    const provider = await UniversalProvider.init({\n        metadata: {\n            description: wcOptions?.appMetadata?.description ||\n                getDefaultAppMetadata().description,\n            icons: [\n                wcOptions?.appMetadata?.logoUrl || getDefaultAppMetadata().logoUrl,\n            ],\n            name: wcOptions?.appMetadata?.name || getDefaultAppMetadata().name,\n            url: wcOptions?.appMetadata?.url || getDefaultAppMetadata().url,\n            redirect: {\n                native: walletInfo.mobile.native || undefined,\n                universal: walletInfo.mobile.universal || undefined,\n            },\n        },\n        projectId: wcOptions?.projectId || DEFAULT_PROJECT_ID,\n    });\n    provider.events.setMaxListeners(Number.POSITIVE_INFINITY);\n    if (walletId !== \"walletConnect\") {\n        async function handleSessionRequest() {\n            const walletLinkToOpen = provider.session?.peer?.metadata?.redirect?.native ||\n                walletInfo.mobile.native ||\n                walletInfo.mobile.universal;\n            if (sessionRequestHandler && walletLinkToOpen) {\n                // TODO: propagate error when this fails\n                await sessionRequestHandler(walletLinkToOpen);\n            }\n        }\n        // For UniversalProvider, use different event handling\n        provider.on(\"session_request_sent\", handleSessionRequest);\n        provider.events.addListener(\"disconnect\", () => {\n            provider.off(\"session_request_sent\", handleSessionRequest);\n            cachedProvider = null;\n        });\n    }\n    cachedProvider = provider;\n    return provider;\n}\nfunction createAccount({ provider, address, client, chain, sessionRequestHandler, walletInfo, }) {\n    const account = {\n        address: getAddress(address),\n        async sendTransaction(tx) {\n            const transactionHash = (await requestAndOpenWallet({\n                provider,\n                payload: {\n                    method: \"eth_sendTransaction\",\n                    params: [\n                        {\n                            data: tx.data,\n                            from: getAddress(address),\n                            gas: tx.gas ? numberToHex(tx.gas) : undefined,\n                            to: tx.to,\n                            value: tx.value ? numberToHex(tx.value) : undefined,\n                        },\n                    ],\n                },\n                chain: `eip155:${tx.chainId}`,\n                walletInfo,\n                sessionRequestHandler,\n            }));\n            trackTransaction({\n                chainId: tx.chainId,\n                client: client,\n                contractAddress: tx.to ?? undefined,\n                gasPrice: tx.gasPrice,\n                transactionHash,\n                walletAddress: getAddress(address),\n                walletType: \"walletConnect\",\n            });\n            return {\n                transactionHash,\n            };\n        },\n        async signMessage({ message }) {\n            const messageToSign = (() => {\n                if (typeof message === \"string\") {\n                    return stringToHex(message);\n                }\n                if (message.raw instanceof Uint8Array) {\n                    return uint8ArrayToHex(message.raw);\n                }\n                return message.raw;\n            })();\n            return requestAndOpenWallet({\n                provider,\n                payload: {\n                    method: \"personal_sign\",\n                    params: [messageToSign, this.address],\n                },\n                chain: `eip155:${chain.id}`,\n                walletInfo,\n                sessionRequestHandler,\n            });\n        },\n        async signTypedData(_data) {\n            const data = parseTypedData(_data);\n            const { domain, message, primaryType } = data;\n            const types = {\n                EIP712Domain: getTypesForEIP712Domain({ domain }),\n                ...data.types,\n            };\n            // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc\n            // as we can't statically check this with TypeScript.\n            validateTypedData({ domain, message, primaryType, types });\n            const typedData = serializeTypedData({\n                domain: domain ?? {},\n                message,\n                primaryType,\n                types,\n            });\n            return await requestAndOpenWallet({\n                provider,\n                payload: {\n                    method: \"eth_signTypedData_v4\",\n                    params: [this.address, typedData],\n                },\n                chain: `eip155:${chain.id}`,\n                walletInfo,\n                sessionRequestHandler,\n            });\n        },\n    };\n    return account;\n}\nasync function requestAndOpenWallet(args) {\n    const { provider, payload, chain, walletInfo, sessionRequestHandler } = args;\n    const resultPromise = provider.request(payload, chain);\n    const walletLinkToOpen = provider.session?.peer?.metadata?.redirect?.native ||\n        walletInfo.mobile.native ||\n        walletInfo.mobile.universal;\n    if (sessionRequestHandler && walletLinkToOpen) {\n        await sessionRequestHandler(walletLinkToOpen);\n    }\n    return resultPromise;\n}\nfunction onConnect(address, chain, provider, emitter, storage, client, walletInfo, sessionRequestHandler) {\n    const account = createAccount({\n        address,\n        chain,\n        client,\n        provider,\n        sessionRequestHandler,\n        walletInfo,\n    });\n    async function disconnect() {\n        provider.removeListener(\"accountsChanged\", onAccountsChanged);\n        provider.removeListener(\"chainChanged\", onChainChanged);\n        provider.removeListener(\"disconnect\", onDisconnect);\n        await provider.disconnect();\n        cachedProvider = null;\n    }\n    function onDisconnect() {\n        setRequestedChainsIds([], storage);\n        storage?.removeItem(storageKeys.lastUsedChainId);\n        disconnect();\n        emitter.emit(\"disconnect\", undefined);\n    }\n    function onAccountsChanged(accounts) {\n        if (accounts[0]) {\n            const newAccount = createAccount({\n                address: getAddress(accounts[0]),\n                chain,\n                client,\n                provider,\n                sessionRequestHandler,\n                walletInfo,\n            });\n            emitter.emit(\"accountChanged\", newAccount);\n            emitter.emit(\"accountsChanged\", accounts);\n        }\n        else {\n            onDisconnect();\n        }\n    }\n    function onChainChanged(newChainId) {\n        const newChain = getCachedChain(normalizeChainId(newChainId));\n        emitter.emit(\"chainChanged\", newChain);\n        storage?.setItem(storageKeys.lastUsedChainId, String(newChainId));\n    }\n    provider.on(\"accountsChanged\", onAccountsChanged);\n    provider.on(\"chainChanged\", onChainChanged);\n    provider.on(\"disconnect\", onDisconnect);\n    provider.on(\"session_delete\", onDisconnect);\n    return [\n        account,\n        chain,\n        disconnect,\n        (newChain) => switchChainWC(provider, newChain, walletInfo),\n    ];\n}\nasync function switchChainWC(provider, chain, walletInfo) {\n    try {\n        await ensureTargetChain(provider, chain, walletInfo);\n    }\n    catch (error) {\n        const message = typeof error === \"string\" ? error : error?.message;\n        if (/user rejected request/i.test(message)) {\n            throw new UserRejectedRequestError(error);\n        }\n        throw new SwitchChainError(error);\n    }\n}\n/**\n * Set the requested chains to the storage.\n * @internal\n */\nfunction setRequestedChainsIds(chains, storage) {\n    storage?.setItem(storageKeys.requestedChains, stringify(chains));\n}\nfunction getChainsToRequest(options) {\n    const rpcMap = {};\n    const chainIds = [];\n    if (options.chain) {\n        rpcMap[options.chain.id] = getRpcUrlForChain({\n            chain: options.chain,\n            client: options.client,\n        });\n        chainIds.push(options.chain.id);\n    }\n    // limit optional chains to 10\n    const optionalChains = (options?.optionalChains || []).slice(0, 10);\n    for (const chain of optionalChains) {\n        rpcMap[chain.id] = getRpcUrlForChain({\n            chain: chain,\n            client: options.client,\n        });\n        chainIds.push(chain.id);\n    }\n    // always include mainnet\n    // many wallets only support a handful of chains, but mainnet is always supported\n    // we will add additional chains in switchChain if needed\n    if (!chainIds.includes(1)) {\n        rpcMap[1] = getCachedChain(1).rpc;\n        chainIds.push(1);\n    }\n    return {\n        chains: chainIds.map((x) => `eip155:${x}`),\n        rpcMap,\n    };\n}\nconst chainsToRequestForSafe = [\n    1, // Ethereum Mainnet\n    11155111, // Sepolia Testnet\n    42161, // Arbitrum One Mainnet\n    43114, // Avalanche Mainnet\n    8453, // Base Mainnet\n    1313161554, // Aurora Mainnet\n    84532, // Base Sepolia Testnet\n    56, // Binance Smart Chain Mainnet\n    42220, // Celo Mainnet\n    100, // Gnosis Mainnet\n    10, // Optimism Mainnet\n    137, // Polygon Mainnet\n    1101, // Polygon zkEVM Mainnet\n    324, // zkSync Era mainnet\n    534352, // Scroll mainnet\n];\n//# sourceMappingURL=controller.js.map"],"file":"assets/controller-sXT7sOp3.js"}