{"version":3,"file":"extractIPFS-DeinzTLk.js","sources":["../../node_modules/thirdweb/dist/esm/utils/base58/alphabet.js","../../node_modules/thirdweb/dist/esm/utils/base58/encode.js","../../node_modules/thirdweb/dist/esm/utils/bytecode/cbor-decode.js","../../node_modules/thirdweb/dist/esm/utils/bytecode/prefix.js","../../node_modules/thirdweb/dist/esm/utils/bytecode/extractIPFS.js"],"sourcesContent":["export const ALPHABET = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\n//# sourceMappingURL=alphabet.js.map","import { ALPHABET } from \"./alphabet.js\";\nconst BASE = ALPHABET.length;\nconst LEADER = /* @__PURE__ */ (() => ALPHABET.charAt(0))();\nconst iFACTOR = /* @__PURE__ */ (() => Math.log(256) / Math.log(BASE))(); // log(256) / log(BASE), rounded up\n/**\n * Encodes a Uint8Array into a base58 string.\n * @param source - The Uint8Array to encode.\n * @returns The base58 encoded string.\n * @throws {TypeError} If the source is not a Uint8Array.\n * @throws {Error} If there is a non-zero carry during the encoding process.\n * @example\n * ```ts\n * import { base58Encode } from \"thirdweb/utils;\n * const source = new Uint8Array([0, 1, 2, 3, 4, 5]);\n * const encoded = base58Encode(source);\n * console.log(encoded);\n * ```\n */\nexport function base58Encode(source) {\n    if (!(source instanceof Uint8Array)) {\n        throw new TypeError(\"Expected Uint8Array\");\n    }\n    if (source.length === 0) {\n        return \"\";\n    }\n    // Skip & count leading zeroes.\n    let zeroes = 0;\n    let length = 0;\n    let pbegin = 0;\n    const pend = source.length;\n    while (pbegin !== pend && source[pbegin] === 0) {\n        pbegin++;\n        zeroes++;\n    }\n    // Allocate enough space in big-endian base58 representation.\n    const size = ((pend - pbegin) * iFACTOR + 1) >>> 0;\n    const b58 = new Uint8Array(size);\n    // Process the bytes.\n    while (pbegin !== pend) {\n        let carry = source[pbegin] || 0;\n        // Apply \"b58 = b58 * 256 + ch\".\n        let i = 0;\n        for (let it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++) {\n            carry += (256 * (b58[it1] || 0)) >>> 0;\n            b58[it1] = (carry % BASE) >>> 0;\n            carry = (carry / BASE) >>> 0;\n        }\n        if (carry !== 0) {\n            throw new Error(\"Non-zero carry\");\n        }\n        length = i;\n        pbegin++;\n    }\n    // Skip leading zeroes in base58 result.\n    let it2 = size - length;\n    while (it2 !== size && b58[it2] === 0) {\n        it2++;\n    }\n    // Translate the result into a string.\n    let str = LEADER.repeat(zeroes);\n    for (; it2 < size; ++it2) {\n        str += ALPHABET.charAt(b58[it2] || 0);\n    }\n    return str;\n}\n//# sourceMappingURL=encode.js.map","/* biome-ignore-all lint: IGNORED */\n// original source: https://github.com/kriszyp/cbor-x/blob/master/decode.js\n// heavily modified to remove all non-essential code\n// TODO: re-enable typescript and properly type this\n// @ts-nocheck - TODO: re-enable typescript and properly type this\nlet src;\nlet srcEnd;\nlet position = 0;\nconst EMPTY_ARRAY = [];\nlet strings = EMPTY_ARRAY;\nlet stringPosition = 0;\nlet currentDecoder = {};\nlet currentStructures;\nlet srcString;\nconst srcStringStart = 0;\nlet srcStringEnd = 0;\nlet bundledStrings;\nlet referenceMap;\nconst currentExtensions = [];\nlet packedValues;\nlet dataView;\nconst defaultOptions = {\n    mapsAsObjects: true,\n    useRecords: false,\n};\nfunction readFixedString(length) {\n    let result;\n    if (length < 16) {\n        if ((result = shortStringInJS(length)))\n            return result;\n    }\n    if (length > 64 && decoder)\n        return decoder.decode(src.subarray(position, (position += length)));\n    const end = position + length;\n    const units = [];\n    result = \"\";\n    while (position < end) {\n        const byte1 = src[position++];\n        if ((byte1 & 0x80) === 0) {\n            // 1 byte\n            units.push(byte1);\n        }\n        else if ((byte1 & 0xe0) === 0xc0) {\n            // 2 bytes\n            const byte2 = src[position++] & 0x3f;\n            units.push(((byte1 & 0x1f) << 6) | byte2);\n        }\n        else if ((byte1 & 0xf0) === 0xe0) {\n            // 3 bytes\n            const byte2 = src[position++] & 0x3f;\n            const byte3 = src[position++] & 0x3f;\n            units.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3);\n        }\n        else if ((byte1 & 0xf8) === 0xf0) {\n            // 4 bytes\n            const byte2 = src[position++] & 0x3f;\n            const byte3 = src[position++] & 0x3f;\n            const byte4 = src[position++] & 0x3f;\n            let unit = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4;\n            if (unit > 0xffff) {\n                unit -= 0x10000;\n                units.push(((unit >>> 10) & 0x3ff) | 0xd800);\n                unit = 0xdc00 | (unit & 0x3ff);\n            }\n            units.push(unit);\n        }\n        else {\n            units.push(byte1);\n        }\n        if (units.length >= 0x1000) {\n            result += fromCharCode.apply(String, units);\n            units.length = 0;\n        }\n    }\n    if (units.length > 0) {\n        result += fromCharCode.apply(String, units);\n    }\n    return result;\n}\nclass Decoder {\n    constructor() {\n        Object.assign(this, defaultOptions);\n    }\n    decodeKey(key) {\n        return key;\n    }\n    decode(source, end = -1) {\n        srcEnd = end > -1 ? end : source.length;\n        position = 0;\n        stringPosition = 0;\n        srcStringEnd = 0;\n        srcString = null;\n        strings = EMPTY_ARRAY;\n        bundledStrings = null;\n        src = source;\n        // this provides cached access to the data view for a buffer if it is getting reused, which is a recommend\n        // technique for getting data from a database where it can be copied into an existing buffer instead of creating\n        // new ones\n        try {\n            dataView =\n                source.dataView ||\n                    (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength));\n        }\n        catch (error) {\n            // if it doesn't have a buffer, maybe it is the wrong type of object\n            src = null;\n            if (source instanceof Uint8Array) {\n                throw error;\n            }\n            throw new Error(`Source must be a Uint8Array or Buffer but was a ${source && typeof source === \"object\"\n                ? source.constructor.name\n                : typeof source}`);\n        }\n        if (this instanceof Decoder) {\n            currentDecoder = this;\n            packedValues =\n                this.sharedValues &&\n                    (this.pack\n                        ? new Array(this.maxPrivatePackedValues || 16).concat(this.sharedValues)\n                        : this.sharedValues);\n            if (!currentStructures || currentStructures.length > 0) {\n                currentStructures = [];\n            }\n        }\n        else {\n            currentDecoder = defaultOptions;\n            if (!currentStructures || currentStructures.length > 0) {\n                currentStructures = [];\n            }\n            packedValues = null;\n        }\n        return checkedRead();\n    }\n}\nfunction checkedRead() {\n    try {\n        const result = read();\n        if (bundledStrings) {\n            if (position >= bundledStrings.postBundlePosition) {\n                const error = new Error(\"Unexpected bundle position\");\n                error.incomplete = true;\n                throw error;\n            }\n            // bundled strings to skip past\n            position = bundledStrings.postBundlePosition;\n            bundledStrings = null;\n        }\n        if (position === srcEnd) {\n            // finished reading this source, cleanup references\n            currentStructures = null;\n            src = null;\n            if (referenceMap) {\n                referenceMap = null;\n            }\n        }\n        else if (position > srcEnd) {\n            // over read\n            const error = new Error(\"Unexpected end of CBOR data\");\n            error.incomplete = true;\n            throw error;\n        }\n        else {\n            throw new Error(\"Data read, but end of buffer not reached\");\n        }\n        // else more to read, but we are reading sequentially, so don't clear source yet\n        return result;\n    }\n    catch (error) {\n        clearSource();\n        if (error instanceof RangeError ||\n            error.message.startsWith(\"Unexpected end of buffer\")) {\n            error.incomplete = true;\n        }\n        throw error;\n    }\n}\nfunction read() {\n    let token = src[position++];\n    const majorType = token >> 5;\n    token = token & 0x1f;\n    if (token > 0x17) {\n        switch (token) {\n            case 0x18:\n                token = src[position++];\n                break;\n            default:\n                throw new Error(`Unknown token ${token}`);\n        }\n    }\n    switch (majorType) {\n        case 0: // positive int\n            return token;\n        case 1: // negative int\n            return ~token;\n        case 2: // buffer\n            return readBin(token);\n        case 3: // string\n            if (srcStringEnd >= position) {\n                return srcString.slice(position - srcStringStart, (position += token) - srcStringStart);\n            }\n            if (srcStringEnd === 0 && srcEnd < 140 && token < 32) {\n                // for small blocks, avoiding the overhead of the extract call is helpful\n                const string = token < 16 ? shortStringInJS(token) : longStringInJS(token);\n                if (string !== null) {\n                    return string;\n                }\n            }\n            return readFixedString(token);\n        case 4: {\n            // array\n            const array = new Array(token);\n            for (let i = 0; i < token; i++) {\n                array[i] = read();\n            }\n            return array;\n        }\n        case 5: {\n            // map\n            const object = {};\n            for (let i = 0; i < token; i++) {\n                object[safeKey(read())] = read();\n            }\n            return object;\n        }\n        default: // negative int\n            if (Number.isNaN(token)) {\n                const error = new Error(\"Unexpected end of CBOR data\");\n                error.incomplete = true;\n                throw error;\n            }\n            throw new Error(`Unknown CBOR token ${token}`);\n    }\n}\nfunction safeKey(key) {\n    // protect against prototype pollution\n    if (typeof key === \"string\") {\n        return key === \"__proto__\" ? \"__proto_\" : key;\n    }\n    if (typeof key !== \"object\") {\n        return key.toString();\n    }\n    // protect against expensive (DoS) string conversions\n    throw new Error(`Invalid property name type ${typeof key}`);\n}\nconst fromCharCode = String.fromCharCode;\nfunction longStringInJS(length) {\n    const start = position;\n    const bytes = new Array(length);\n    for (let i = 0; i < length; i++) {\n        const byte = src[position++];\n        if ((byte & 0x80) > 0) {\n            position = start;\n            return;\n        }\n        bytes[i] = byte;\n    }\n    return fromCharCode.apply(String, bytes);\n}\nfunction shortStringInJS(length) {\n    if (length < 4) {\n        if (length < 2) {\n            if (length === 0) {\n                return \"\";\n            }\n            const a = src[position++];\n            if ((a & 0x80) > 1) {\n                position -= 1;\n                return;\n            }\n            return fromCharCode(a);\n        }\n        const a = src[position++];\n        const b = src[position++];\n        if ((a & 0x80) > 0 || (b & 0x80) > 0) {\n            position -= 2;\n            return;\n        }\n        if (length < 3) {\n            return fromCharCode(a, b);\n        }\n        const c = src[position++];\n        if ((c & 0x80) > 0) {\n            position -= 3;\n            return;\n        }\n        return fromCharCode(a, b, c);\n    }\n    const a = src[position++];\n    const b = src[position++];\n    const c = src[position++];\n    const d = src[position++];\n    if ((a & 0x80) > 0 || (b & 0x80) > 0 || (c & 0x80) > 0 || (d & 0x80) > 0) {\n        position -= 4;\n        return;\n    }\n    if (length < 6) {\n        if (length === 4) {\n            return fromCharCode(a, b, c, d);\n        }\n        const e = src[position++];\n        if ((e & 0x80) > 0) {\n            position -= 5;\n            return;\n        }\n        return fromCharCode(a, b, c, d, e);\n    }\n    if (length < 8) {\n        const e = src[position++];\n        const f = src[position++];\n        if ((e & 0x80) > 0 || (f & 0x80) > 0) {\n            position -= 6;\n            return;\n        }\n        if (length < 7) {\n            return fromCharCode(a, b, c, d, e, f);\n        }\n        const g = src[position++];\n        if ((g & 0x80) > 0) {\n            position -= 7;\n            return;\n        }\n        return fromCharCode(a, b, c, d, e, f, g);\n    }\n    const e = src[position++];\n    const f = src[position++];\n    const g = src[position++];\n    const h = src[position++];\n    if ((e & 0x80) > 0 || (f & 0x80) > 0 || (g & 0x80) > 0 || (h & 0x80) > 0) {\n        position -= 8;\n        return;\n    }\n    if (length < 10) {\n        if (length === 8) {\n            return fromCharCode(a, b, c, d, e, f, g, h);\n        }\n        const i = src[position++];\n        if ((i & 0x80) > 0) {\n            position -= 9;\n            return;\n        }\n        return fromCharCode(a, b, c, d, e, f, g, h, i);\n    }\n    if (length < 12) {\n        const i = src[position++];\n        const j = src[position++];\n        if ((i & 0x80) > 0 || (j & 0x80) > 0) {\n            position -= 10;\n            return;\n        }\n        if (length < 11) {\n            return fromCharCode(a, b, c, d, e, f, g, h, i, j);\n        }\n        const k = src[position++];\n        if ((k & 0x80) > 0) {\n            position -= 11;\n            return;\n        }\n        return fromCharCode(a, b, c, d, e, f, g, h, i, j, k);\n    }\n    const i = src[position++];\n    const j = src[position++];\n    const k = src[position++];\n    const l = src[position++];\n    if ((i & 0x80) > 0 || (j & 0x80) > 0 || (k & 0x80) > 0 || (l & 0x80) > 0) {\n        position -= 12;\n        return;\n    }\n    if (length < 14) {\n        if (length === 12) {\n            return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l);\n        }\n        const m = src[position++];\n        if ((m & 0x80) > 0) {\n            position -= 13;\n            return;\n        }\n        return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m);\n    }\n    const m = src[position++];\n    const n = src[position++];\n    if ((m & 0x80) > 0 || (n & 0x80) > 0) {\n        position -= 14;\n        return;\n    }\n    if (length < 15) {\n        return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n);\n    }\n    const o = src[position++];\n    if ((o & 0x80) > 0) {\n        position -= 15;\n        return;\n    }\n    return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o);\n}\nfunction readBin(length) {\n    return currentDecoder.copyBuffers\n        ? // specifically use the copying slice (not the node one)\n            Uint8Array.prototype.slice.call(src, position, (position += length))\n        : src.subarray(position, (position += length));\n}\nconst glbl = { Error, RegExp };\ncurrentExtensions[27] = (data) => {\n    // http://cbor.schmorp.de/generic-object\n    return (glbl[data[0]] || Error)(data[1], data[2]);\n};\nconst packedTable = (read_) => {\n    if (src[position++] !== 0x84) {\n        const error = new Error(\"Packed values structure must be followed by a 4 element array\");\n        if (src.length < position) {\n            error.incomplete = true;\n        }\n        throw error;\n    }\n    const newPackedValues = read_(); // packed values\n    if (!newPackedValues || !newPackedValues.length) {\n        const error = new Error(\"Packed values structure must be followed by a 4 element array\");\n        error.incomplete = true;\n        throw error;\n    }\n    packedValues = packedValues\n        ? newPackedValues.concat(packedValues.slice(newPackedValues.length))\n        : newPackedValues;\n    packedValues.prefixes = read_();\n    packedValues.suffixes = read_();\n    return read_(); // read the rump\n};\npackedTable.handlesRead = true;\ncurrentExtensions[28] = (read_) => {\n    // shareable http://cbor.schmorp.de/value-sharing (for structured clones)\n    if (!referenceMap) {\n        referenceMap = new Map();\n        referenceMap.id = 0;\n    }\n    const id = referenceMap.id++;\n    const token = src[position];\n    let target;\n    // TODO: handle Maps, Sets, and other types that can cycle; this is complicated, because you potentially need to read\n    // ahead past references to record structure definitions\n    if (token >> 5 === 4) {\n        target = [];\n    }\n    else {\n        target = {};\n    }\n    const refEntry = { target }; // a placeholder object\n    referenceMap.set(id, refEntry);\n    const targetProperties = read_(); // read the next value as the target object to id\n    if (refEntry.used) {\n        // there is a cycle, so we have to assign properties to original target\n        return Object.assign(target, targetProperties);\n    }\n    refEntry.target = targetProperties; // the placeholder wasn't used, replace with the deserialized one\n    return targetProperties; // no cycle, can just use the returned read object\n};\nfunction clearSource() {\n    src = null;\n    referenceMap = null;\n    currentStructures = null;\n}\nconst mult10 = new Array(147); // this is a table matching binary exponents to the multiplier to determine significant digit rounding\nfor (let i = 0; i < 256; i++) {\n    mult10[i] = /* @__PURE__ */ (() => Number(`1e${Math.floor(45.15 - i * 0.30103)}`))();\n}\nconst defaultDecoder = new Decoder();\nexport const decode = defaultDecoder.decode;\n//# sourceMappingURL=cbor-decode.js.map","import { isHex } from \"../encoding/hex.js\";\n/**\n * Ensures that the given bytecode has the correct prefix.\n * If the bytecode already starts with \"0x\", it is returned as is.\n * Otherwise, the prefix \"0x\" is added to the bytecode.\n * @param bytecode - The bytecode to ensure the prefix for.\n * @returns The bytecode with the correct prefix.\n * @example\n * ```ts\n * import { ensureBytecodePrefix } from \"thirdweb/utils/bytecode/prefix\";\n * const bytecode = \"363d3d373d3d3d363d30545af43d82803e903d91601857fd5bf3\";\n * const prefixedBytecode = ensureBytecodePrefix(bytecode);\n * console.log(prefixedBytecode);\n * ```\n * @utils\n */\nexport function ensureBytecodePrefix(bytecode) {\n    if (isHex(bytecode, { strict: false })) {\n        return bytecode;\n    }\n    return `0x${bytecode}`;\n}\n//# sourceMappingURL=prefix.js.map","import { base58Encode } from \"../base58/encode.js\";\nimport { hexToBytes } from \"../encoding/to-bytes.js\";\nimport { decode } from \"./cbor-decode.js\";\nimport { ensureBytecodePrefix } from \"./prefix.js\";\n/**\n * Extracts the IPFS URI from the given bytecode.\n * @param bytecode - The bytecode to extract the IPFS URI from.\n * @returns The IPFS URI if found, otherwise undefined.\n * @example\n * ```ts\n * import { extractIPFSUri } from \"thirdweb/utils/bytecode/extractIPFS\";\n * const bytecode = \"0x363d3d373d3d3d363d30545af43d82803e903d91601857fd5bf3\";\n * const ipfsHash = extractIPFSUri(bytecode);\n * console.log(ipfsHash);\n * ```\n * @utils\n */\nexport function extractIPFSUri(bytecode) {\n    const numericBytecode = hexToBytes(ensureBytecodePrefix(bytecode));\n    const cborLength = \n    // @ts-expect-error - TS doesn't like this, but it's fine\n    numericBytecode[numericBytecode.length - 2] * 0x100 +\n        // @ts-expect-error - TS doesn't like this, but it's fine\n        numericBytecode[numericBytecode.length - 1];\n    const cborStart = numericBytecode.length - 2 - cborLength;\n    // if the cborStart is invalid, return undefined\n    if (cborStart < 0 || cborStart > numericBytecode.length) {\n        return undefined;\n    }\n    const bytecodeBuffer = numericBytecode.slice(cborStart, -2);\n    const cborData = decode(bytecodeBuffer);\n    if (\"ipfs\" in cborData) {\n        return `ipfs://${base58Encode(cborData.ipfs)}`;\n    }\n    return undefined;\n}\n//# sourceMappingURL=extractIPFS.js.map"],"names":["ALPHABET","BASE","LEADER","iFACTOR","base58Encode","source","zeroes","length","pbegin","pend","size","b58","carry","i","it1","it2","str","src","srcEnd","position","currentDecoder","currentStructures","srcString","srcStringStart","srcStringEnd","bundledStrings","referenceMap","dataView","defaultOptions","readFixedString","result","shortStringInJS","end","units","byte1","byte2","byte3","byte4","unit","fromCharCode","Decoder","key","error","checkedRead","read","clearSource","token","majorType","readBin","string","longStringInJS","array","object","safeKey","start","bytes","byte","a","b","c","d","e","f","g","h","j","k","l","m","n","o","mult10","defaultDecoder","decode","ensureBytecodePrefix","bytecode","isHex","extractIPFSUri","numericBytecode","hexToBytes","cborLength","cborStart","bytecodeBuffer","cborData"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4]}